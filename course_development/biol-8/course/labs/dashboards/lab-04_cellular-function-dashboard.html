<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lab 4 Dashboard: Cellular Function | BIOL-8</title>
<style>
/* ═══════════════════════════════════════════════════════════════════════
   RESET & BASE
   ═══════════════════════════════════════════════════════════════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #f0f2f5; --card: #ffffff; --sidebar: #1a1a2e; --sidebar-hover: #252545;
  --accent: #c41e3a; --accent-light: #e8354f; --blue: #2563eb; --blue-light: #3b82f6;
  --green: #16a34a; --amber: #d97706; --purple: #7c3aed;
  --text: #1a1a1a; --text-muted: #6b7280; --border: #e5e7eb;
  --radius: 10px; --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1);
  --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
  --mono: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
}
html { scroll-behavior: smooth; }
body { font-family: var(--font); background: var(--bg); color: var(--text); line-height: 1.6; }

/* ═══════════════════════════════════════════════════════════════════════
   LAYOUT
   ═══════════════════════════════════════════════════════════════════════ */
.layout { display: flex; min-height: 100vh; }
.sidebar {
  width: 260px; background: var(--sidebar); color: #e2e8f0; position: fixed;
  top: 0; left: 0; height: 100vh; overflow-y: auto; z-index: 100;
  display: flex; flex-direction: column;
}
.sidebar-header { padding: 24px 20px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); }
.sidebar-header h1 { font-size: 15px; font-weight: 700; color: #fff; letter-spacing: 0.5px; }
.sidebar-header p { font-size: 12px; color: #94a3b8; margin-top: 4px; }
.sidebar-nav { flex: 1; padding: 12px 0; }
.sidebar-nav a {
  display: flex; align-items: center; gap: 10px; padding: 10px 20px;
  color: #94a3b8; text-decoration: none; font-size: 13px; font-weight: 500;
  transition: all 0.15s; border-left: 3px solid transparent;
}
.sidebar-nav a:hover { background: var(--sidebar-hover); color: #e2e8f0; }
.sidebar-nav a.active { color: #fff; background: var(--sidebar-hover); border-left-color: var(--accent); }
.sidebar-nav .nav-num {
  display: inline-flex; align-items: center; justify-content: center;
  width: 22px; height: 22px; border-radius: 6px; font-size: 11px; font-weight: 700;
  background: rgba(255,255,255,0.08); flex-shrink: 0;
}
.sidebar-nav a.active .nav-num { background: var(--accent); color: #fff; }
.sidebar-footer { padding: 16px 20px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 11px; color: #64748b; }

.main { margin-left: 260px; flex: 1; padding: 32px; max-width: 1200px; }

/* ═══════════════════════════════════════════════════════════════════════
   CARDS & SECTIONS
   ═══════════════════════════════════════════════════════════════════════ */
.section { margin-bottom: 40px; scroll-margin-top: 24px; }
.section-header {
  display: flex; align-items: center; gap: 12px; margin-bottom: 20px;
}
.section-num {
  display: flex; align-items: center; justify-content: center;
  width: 36px; height: 36px; border-radius: 10px;
  background: var(--accent); color: #fff; font-weight: 800; font-size: 16px; flex-shrink: 0;
}
.section-title { font-size: 22px; font-weight: 700; }
.section-subtitle { font-size: 13px; color: var(--text-muted); margin-top: 2px; }

.card {
  background: var(--card); border-radius: var(--radius); box-shadow: var(--shadow);
  padding: 24px; margin-bottom: 16px; border: 1px solid var(--border);
}
.card-title { font-size: 15px; font-weight: 700; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
.card-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.card-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
@media (max-width: 900px) { .card-row, .card-row-3 { grid-template-columns: 1fr; } }

/* ═══════════════════════════════════════════════════════════════════════
   BUTTONS & INPUTS
   ═══════════════════════════════════════════════════════════════════════ */
.btn {
  display: inline-flex; align-items: center; justify-content: center; gap: 6px;
  padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 600;
  border: none; cursor: pointer; transition: all 0.15s; font-family: var(--font);
}
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: var(--accent-light); transform: translateY(-1px); box-shadow: var(--shadow-lg); }
.btn-secondary { background: var(--blue); color: #fff; }
.btn-secondary:hover { background: var(--blue-light); }
.btn-outline { background: transparent; color: var(--text); border: 2px solid var(--border); }
.btn-outline:hover { border-color: var(--accent); color: var(--accent); }
.btn-sm { padding: 6px 14px; font-size: 12px; }
.btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }

.slider-group { display: flex; align-items: center; gap: 12px; margin: 8px 0; }
.slider-group label { font-size: 13px; font-weight: 600; min-width: 80px; }
.slider-group input[type=range] { flex: 1; accent-color: var(--accent); }
.slider-val { font-family: var(--mono); font-size: 14px; font-weight: 700; min-width: 50px; text-align: right; }

/* ═══════════════════════════════════════════════════════════════════════
   STATS & BADGES
   ═══════════════════════════════════════════════════════════════════════ */
.stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin: 12px 0; }
.stat-box {
  text-align: center; padding: 14px 8px; border-radius: 8px;
  background: #f8fafc; border: 1px solid var(--border);
}
.stat-box .stat-val { font-size: 28px; font-weight: 800; font-family: var(--mono); }
.stat-box .stat-label { font-size: 11px; color: var(--text-muted); margin-top: 2px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.stat-accent .stat-val { color: var(--accent); }
.stat-blue .stat-val { color: var(--blue); }
.stat-green .stat-val { color: var(--green); }
.stat-amber .stat-val { color: var(--amber); }
.stat-purple .stat-val { color: var(--purple); }

.badge {
  display: inline-block; padding: 2px 10px; border-radius: 20px;
  font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
}
.badge-red { background: #fef2f2; color: var(--accent); }
.badge-blue { background: #eff6ff; color: var(--blue); }
.badge-green { background: #f0fdf4; color: var(--green); }

/* ═══════════════════════════════════════════════════════════════════════
   CHART CONTAINERS
   ═══════════════════════════════════════════════════════════════════════ */
.chart-wrap { position: relative; width: 100%; margin: 8px 0; }
.chart-wrap canvas { width: 100% !important; display: block; border-radius: 6px; }

/* ═══════════════════════════════════════════════════════════════════════
   DATA GRID
   ═══════════════════════════════════════════════════════════════════════ */
.data-grid {
  display: grid; gap: 3px; margin: 10px 0; font-family: var(--mono); font-size: 14px;
}
.data-grid .cell {
  display: flex; align-items: center; justify-content: center;
  height: 38px; border-radius: 4px; font-weight: 700; transition: all 0.2s;
}
.data-grid .cell-header { background: #1a1a1a; color: #fff; font-size: 11px; font-weight: 600; }
.data-grid .cell-label { background: #f1f5f9; color: var(--text); font-size: 12px; font-weight: 600; }
.data-grid .cell-empty { background: #fafafa; border: 1px dashed #d1d5db; color: #d1d5db; }
.data-grid .cell-new { animation: cellPop 0.3s ease; }
@keyframes cellPop { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

/* ═══════════════════════════════════════════════════════════════════════
   ANALYSIS PANEL
   ═══════════════════════════════════════════════════════════════════════ */
.analysis-result {
  background: #f8fafc; border-radius: 8px; padding: 16px; margin: 10px 0;
  border-left: 4px solid var(--blue); font-size: 14px;
}
.analysis-result .ar-title { font-weight: 700; margin-bottom: 6px; }
.analysis-result code { font-family: var(--mono); background: #e2e8f0; padding: 1px 6px; border-radius: 4px; font-size: 13px; }
.analysis-result.ar-pass { border-left-color: var(--green); }
.analysis-result.ar-fail { border-left-color: var(--accent); }

/* ═══════════════════════════════════════════════════════════════════════
   HERO BANNER
   ═══════════════════════════════════════════════════════════════════════ */
.hero {
  background: linear-gradient(135deg, #1a1a2e 0%, #2d1b3d 50%, #3b1a2e 100%);
  color: #fff; border-radius: var(--radius); padding: 36px; margin-bottom: 32px;
  position: relative; overflow: hidden;
}
.hero::after {
  content: ''; position: absolute; top: -50%; right: -20%; width: 500px; height: 500px;
  background: radial-gradient(circle, rgba(196,30,58,0.15) 0%, transparent 70%);
  pointer-events: none;
}
.hero h2 { font-size: 28px; font-weight: 800; margin-bottom: 8px; }
.hero p { font-size: 15px; color: #cbd5e1; max-width: 600px; line-height: 1.7; }
.hero .bio-tags { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; }
.hero .bio-tag {
  padding: 4px 14px; border-radius: 20px; font-size: 12px; font-weight: 600;
  background: rgba(255,255,255,0.1); backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.15);
}

/* ═══════════════════════════════════════════════════════════════════════
   INFO PANEL (organelle / cell info)
   ═══════════════════════════════════════════════════════════════════════ */
.info-panel {
  background: #f8fafc; border-radius: 8px; padding: 16px; margin: 10px 0;
  border-left: 4px solid var(--blue); font-size: 14px; min-height: 60px;
  transition: all 0.3s;
}
.info-panel .ip-title { font-weight: 700; font-size: 16px; margin-bottom: 4px; color: var(--accent); }
.info-panel .ip-function { margin-bottom: 4px; }
.info-panel .ip-context { color: var(--text-muted); font-style: italic; }

/* ═══════════════════════════════════════════════════════════════════════
   TOGGLE GRID (cell comparison)
   ═══════════════════════════════════════════════════════════════════════ */
.toggle-grid {
  display: grid; gap: 4px; margin: 12px 0; font-size: 13px;
}
.toggle-grid .tg-cell {
  display: flex; align-items: center; justify-content: center;
  padding: 10px 6px; border-radius: 6px; font-weight: 600;
  transition: all 0.2s; cursor: pointer; user-select: none;
}
.tg-header { background: #1a1a1a; color: #fff; cursor: default !important; }
.tg-label { background: #f1f5f9; color: var(--text); cursor: default !important; font-size: 12px; }
.tg-on { background: #dcfce7; color: #166534; border: 2px solid #86efac; }
.tg-off { background: #fef2f2; color: #991b1b; border: 2px solid #fecaca; }
.tg-na { background: #f5f5f5; color: #9ca3af; border: 1px solid #e5e7eb; cursor: default !important; }

/* ═══════════════════════════════════════════════════════════════════════
   DRAG & DROP
   ═══════════════════════════════════════════════════════════════════════ */
.drag-item {
  padding: 10px 16px; border-radius: 8px; font-size: 13px; font-weight: 600;
  cursor: grab; transition: all 0.15s; user-select: none; margin: 4px;
  display: inline-block;
}
.drag-item:active { cursor: grabbing; }
.drag-item.matched { opacity: 0.4; cursor: default; }
.drop-zone {
  min-height: 44px; border: 2px dashed var(--border); border-radius: 8px;
  display: flex; align-items: center; justify-content: center; padding: 8px;
  transition: all 0.15s; font-size: 13px; color: var(--text-muted);
}
.drop-zone.over { border-color: var(--accent); background: #fef2f2; }
.drop-zone.correct { border-color: var(--green); background: #f0fdf4; }
.drop-zone.incorrect { border-color: var(--accent); background: #fef2f2; animation: shake 0.4s; }
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-6px); }
  75% { transform: translateX(6px); }
}

/* ═══════════════════════════════════════════════════════════════════════
   CELL GALLERY
   ═══════════════════════════════════════════════════════════════════════ */
.cell-gallery {
  display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin: 12px 0;
}
.cell-gallery-item {
  text-align: center; padding: 12px; border-radius: 8px;
  background: #f8fafc; border: 2px solid var(--border);
  cursor: pointer; transition: all 0.2s;
}
.cell-gallery-item:hover { border-color: var(--accent); transform: translateY(-2px); box-shadow: var(--shadow-lg); }
.cell-gallery-item.selected { border-color: var(--accent); background: #fef2f2; }
.cell-gallery-item canvas { display: block; margin: 0 auto 8px; border-radius: 6px; }
.cell-gallery-item .cg-label { font-size: 12px; font-weight: 700; }

/* ═══════════════════════════════════════════════════════════════════════
   RESPONSIVE
   ═══════════════════════════════════════════════════════════════════════ */
@media (max-width: 768px) {
  .sidebar { display: none; }
  .main { margin-left: 0; padding: 16px; }
}
</style>
</head>
<body>
<div class="layout">

<!-- ═══════════════════════════════════════════════════════════════════════
     SIDEBAR
     ═══════════════════════════════════════════════════════════════════════ -->
<aside class="sidebar">
  <div class="sidebar-header">
    <h1>BIOL-8: Human Biology</h1>
    <p>Lab 4 &mdash; Cellular Function</p>
  </div>
  <nav class="sidebar-nav">
    <a href="#hero" class="active"><span class="nav-num">&bull;</span> Overview</a>
    <a href="#part1"><span class="nav-num">1</span> Human Cell Explorer</a>
    <a href="#part2"><span class="nav-num">2</span> Microscope Simulator</a>
    <a href="#part3"><span class="nav-num">3</span> Cell Type Comparison</a>
    <a href="#part4"><span class="nav-num">4</span> Organelle Matching</a>
    <a href="#part5"><span class="nav-num">5</span> Cell as Factory</a>
    <a href="#part6"><span class="nav-num">6</span> Human Cell Diversity</a>
  </nav>
  <div class="sidebar-footer">Interactive Lab Dashboard<br>&copy; 2026 BIOL-8</div>
</aside>

<!-- ═══════════════════════════════════════════════════════════════════════
     MAIN CONTENT
     ═══════════════════════════════════════════════════════════════════════ -->
<div class="main">

<!-- HERO -->
<div class="hero" id="hero">
  <h2>Cellular Function</h2>
  <p>Explore the microscopic world of human cells. Interact with organelles, compare cell types, simulate microscope views, and discover how cellular structure enables human body functions.</p>
  <div class="bio-tags">
    <span class="bio-tag">Cell Biology</span>
    <span class="bio-tag">Microscopy</span>
    <span class="bio-tag">Human Cells</span>
  </div>
</div>

<!-- ═══════════════════════ PART 1: HUMAN CELL EXPLORER ════════════════ -->
<div class="section" id="part1">
  <div class="section-header">
    <div class="section-num">1</div>
    <div><div class="section-title">Human Cell Explorer</div>
    <div class="section-subtitle">Click organelles to learn their function and importance in the human body</div></div>
  </div>
  <div class="card">
    <div class="card-title">Interactive Animal Cell</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:12px;">Click on any organelle in the cell diagram below. Hover to highlight.</p>
    <div class="chart-wrap"><canvas id="cell-explorer" height="480"></canvas></div>
    <div class="info-panel" id="explorer-info">
      <div class="ip-title">Select an organelle</div>
      <div class="ip-function">Click on any structure in the cell diagram above to learn about its function.</div>
    </div>
    <div class="stat-grid" id="explorer-stats">
      <div class="stat-box stat-accent"><div class="stat-val" id="exp-clicked">0</div><div class="stat-label">Explored</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="exp-total">10</div><div class="stat-label">Total Organelles</div></div>
      <div class="stat-box stat-green"><div class="stat-val" id="exp-pct">0%</div><div class="stat-label">Progress</div></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 2: MICROSCOPE SIMULATOR ═══════════════ -->
<div class="section" id="part2">
  <div class="section-header">
    <div class="section-num">2</div>
    <div><div class="section-title">Microscope Simulator</div>
    <div class="section-subtitle">View prepared slides at different magnifications</div></div>
  </div>
  <div class="card">
    <div class="card-title">Virtual Microscope</div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="setSlide('cheek')">Cheek Epithelial</button>
      <button class="btn btn-secondary" onclick="setSlide('blood')">Blood Smear</button>
      <button class="btn btn-outline" onclick="setSlide('onion')">Onion Epidermis</button>
    </div>
    <div class="btn-group">
      <button class="btn btn-sm btn-outline" onclick="setMag(40)">40x</button>
      <button class="btn btn-sm btn-outline" onclick="setMag(100)">100x</button>
      <button class="btn btn-sm btn-outline" onclick="setMag(400)">400x</button>
    </div>
    <div class="stat-grid">
      <div class="stat-box stat-accent"><div class="stat-val" id="micro-slide">Cheek</div><div class="stat-label">Current Slide</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="micro-mag">40x</div><div class="stat-label">Magnification</div></div>
      <div class="stat-box stat-green"><div class="stat-val" id="micro-type">Animal</div><div class="stat-label">Cell Type</div></div>
    </div>
    <div class="chart-wrap"><canvas id="microscope-canvas" height="480"></canvas></div>
    <div class="info-panel" id="micro-info">
      <div class="ip-title">Cheek Epithelial Cells &mdash; 40x</div>
      <div class="ip-function">At low power, you can see clusters of flat, irregularly shaped cells. These are squamous epithelial cells from the inner lining of the cheek.</div>
      <div class="ip-context">Animal cells: no cell wall, no chloroplasts. Notice the thin cell membrane and visible nucleus.</div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 3: CELL TYPE COMPARISON ═══════════════ -->
<div class="section" id="part3">
  <div class="section-header">
    <div class="section-num">3</div>
    <div><div class="section-title">Cell Type Comparison</div>
    <div class="section-subtitle">Compare prokaryotic, animal, and plant cells side by side</div></div>
  </div>
  <div class="card">
    <div class="card-title">Feature Comparison Matrix</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:12px;">Click cells to toggle features. Green = present, Red = absent.</p>
    <div class="toggle-grid" id="compare-grid" style="grid-template-columns: 180px 1fr 1fr 1fr;"></div>
  </div>
  <div class="card">
    <div class="card-title">Size Scale Comparison</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:12px;">Relative sizes of different cell types drawn to scale.</p>
    <div class="chart-wrap"><canvas id="size-scale-canvas" height="200"></canvas></div>
  </div>
  <div class="card">
    <div class="card-title">Visual Venn Diagram</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:12px;">Shared and unique features of prokaryotic, animal, and plant cells.</p>
    <div class="chart-wrap"><canvas id="venn-canvas" height="380"></canvas></div>
  </div>
</div>

<!-- ═══════════════════════ PART 4: ORGANELLE MATCHING ═════════════════ -->
<div class="section" id="part4">
  <div class="section-header">
    <div class="section-num">4</div>
    <div><div class="section-title">Organelle Function Matching</div>
    <div class="section-subtitle">Match each function description to the correct organelle</div></div>
  </div>
  <div class="card">
    <div class="card-title">Drag-and-Match Challenge</div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="matchStart()">New Game</button>
      <button class="btn btn-secondary" onclick="matchStartTimed()">Timed Challenge</button>
      <button class="btn btn-outline" onclick="matchReset()">Reset</button>
    </div>
    <div class="stat-grid">
      <div class="stat-box stat-accent"><div class="stat-val" id="match-score">0</div><div class="stat-label">Score</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="match-attempts">0</div><div class="stat-label">Attempts</div></div>
      <div class="stat-box stat-green"><div class="stat-val" id="match-accuracy">-</div><div class="stat-label">Accuracy</div></div>
      <div class="stat-box stat-amber"><div class="stat-val" id="match-timer">-</div><div class="stat-label">Timer</div></div>
    </div>
    <div class="chart-wrap"><canvas id="match-canvas" height="520"></canvas></div>
  </div>
</div>

<!-- ═══════════════════════ PART 5: CELL AS FACTORY ═══════════════════ -->
<div class="section" id="part5">
  <div class="section-header">
    <div class="section-num">5</div>
    <div><div class="section-title">Cell as Factory Analogy</div>
    <div class="section-subtitle">Map organelles to factory departments to understand cellular organization</div></div>
  </div>
  <div class="card">
    <div class="card-title">Interactive Factory Diagram</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:12px;">Click on any department in the factory to see its organelle equivalent. The factory analogy helps relate cellular functions to familiar concepts.</p>
    <div class="chart-wrap"><canvas id="factory-canvas" height="500"></canvas></div>
    <div class="info-panel" id="factory-info">
      <div class="ip-title">Click a Department</div>
      <div class="ip-function">Click on any section of the factory diagram above to learn which organelle it represents and why.</div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 6: HUMAN CELL DIVERSITY ═══════════════ -->
<div class="section" id="part6">
  <div class="section-header">
    <div class="section-num">6</div>
    <div><div class="section-title">Human Cell Diversity</div>
    <div class="section-subtitle">Explore specialized cell types and how structure relates to function</div></div>
  </div>
  <div class="card">
    <div class="card-title">Specialized Cell Gallery</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:12px;">Click a cell type to view it on the canvas and learn about its structure-function relationship.</p>
    <div class="cell-gallery" id="cell-gallery"></div>
    <div class="chart-wrap"><canvas id="diversity-canvas" height="400"></canvas></div>
    <div class="info-panel" id="diversity-info">
      <div class="ip-title">Select a Cell Type</div>
      <div class="ip-function">Click any cell in the gallery above to explore its unique structure and learn why it is shaped the way it is.</div>
    </div>
  </div>
</div>

</div><!-- /main -->
</div><!-- /layout -->

<!-- ═══════════════════════════════════════════════════════════════════════
     JAVASCRIPT ENGINE
     ═══════════════════════════════════════════════════════════════════════ -->
<script>
// -- Utility ---------------------------------------------------------------
const $ = id => document.getElementById(id);
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

// -- Chart helper -----------------------------------------------------------
function getCtx(id) {
  const c = $(id); const dpr = window.devicePixelRatio || 1;
  const w = c.offsetWidth || c.width || 300;
  const h = c.offsetHeight || c.height || 150;
  c.width = w * dpr; c.height = h * dpr;
  const ctx = c.getContext('2d'); ctx.scale(dpr, dpr);
  ctx.W = w; ctx.H = h;
  return ctx;
}

function drawBarChart(ctx, opts = {}) {
  const { labels, values, expected, colors, maxVal, yLabel } = opts;
  const W = ctx.W, H = ctx.H;
  const pad = { top: 20, right: 20, bottom: 40, left: 50 };
  const plotW = W - pad.left - pad.right, plotH = H - pad.top - pad.bottom;
  const n = values.length, barW = plotW / n * 0.6, gap = plotW / n * 0.4;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const mv = maxVal || Math.max(...values, ...(expected||[0])) * 1.2 || 10;
  ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + plotH * (1 - i/4);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    ctx.fillStyle = '#9ca3af'; ctx.font = '11px system-ui';
    ctx.textAlign = 'right'; ctx.fillText((mv * i/4).toFixed(mv > 10 ? 0 : 2), pad.left - 6, y + 4);
  }

  values.forEach((v, i) => {
    const x = pad.left + (plotW / n) * i + gap/2;
    const h = (v / mv) * plotH;
    ctx.fillStyle = colors ? colors[i] : '#c41e3a';
    ctx.beginPath();
    const r = 4;
    ctx.moveTo(x, pad.top + plotH);
    ctx.lineTo(x, pad.top + plotH - h + r);
    ctx.quadraticCurveTo(x, pad.top + plotH - h, x + r, pad.top + plotH - h);
    ctx.lineTo(x + barW - r, pad.top + plotH - h);
    ctx.quadraticCurveTo(x + barW, pad.top + plotH - h, x + barW, pad.top + plotH - h + r);
    ctx.lineTo(x + barW, pad.top + plotH);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
    ctx.fillText(labels[i], x + barW/2, H - pad.bottom + 16);
    if (v > 0) {
      ctx.fillStyle = '#1a1a1a'; ctx.font = 'bold 12px system-ui';
      ctx.fillText(v.toFixed(v % 1 ? 2 : 0), x + barW/2, pad.top + plotH - h - 6);
    }
  });

  if (expected) {
    expected.forEach((ev, i) => {
      const x = pad.left + (plotW / n) * i + gap/2;
      const y = pad.top + plotH - (ev / mv) * plotH;
      ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.setLineDash([4,3]);
      ctx.beginPath(); ctx.moveTo(x - 4, y); ctx.lineTo(x + barW + 4, y); ctx.stroke();
      ctx.setLineDash([]);
    });
  }
}

function drawLineChart(ctx, series, opts = {}) {
  const W = ctx.W, H = ctx.H;
  const pad = { top: 20, right: 20, bottom: 30, left: 50 };
  const plotW = W - pad.left - pad.right, plotH = H - pad.top - pad.bottom;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const { yMin = 0, yMax = 1, refLine, xLabel } = opts;
  const yRange = yMax - yMin;
  ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + plotH * (1 - i/4);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    ctx.fillStyle = '#9ca3af'; ctx.font = '11px system-ui'; ctx.textAlign = 'right';
    ctx.fillText((yMin + yRange * i/4).toFixed(2), pad.left - 6, y + 4);
  }
  if (refLine !== undefined) {
    const ry = pad.top + plotH * (1 - (refLine - yMin) / yRange);
    ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.setLineDash([6,4]);
    ctx.beginPath(); ctx.moveTo(pad.left, ry); ctx.lineTo(W - pad.right, ry); ctx.stroke();
    ctx.setLineDash([]);
  }

  series.forEach(s => {
    if (!s.data.length) return;
    const xMax = opts.xMax || s.data.length;
    ctx.strokeStyle = s.color; ctx.lineWidth = s.width || 2;
    ctx.beginPath();
    s.data.forEach((v, i) => {
      const x = pad.left + (i / Math.max(xMax - 1, 1)) * plotW;
      const y = pad.top + plotH * (1 - (v - yMin) / yRange);
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    if (s.width !== 0) ctx.stroke();
    if (s.dots && s.data.length < 80) {
      s.data.forEach((v, i) => {
        const x = pad.left + (i / Math.max(xMax - 1, 1)) * plotW;
        const y = pad.top + plotH * (1 - (v - yMin) / yRange);
        ctx.fillStyle = s.color; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
      });
    }
  });
}


// ══════════════════════════════════════════════════════════════════════════
// PART 1: HUMAN CELL EXPLORER
// ══════════════════════════════════════════════════════════════════════════
const organelleData = [
  { id: 'nucleus', name: 'Nucleus', color: '#7c3aed', func: 'Contains DNA and controls cell activities. Acts as the "brain" of the cell, directing protein synthesis and cell division.', context: 'Every nucleated human cell contains about 2 meters of DNA. Red blood cells lose their nucleus to carry more hemoglobin.', shape: 'circle' },
  { id: 'mitochondria', name: 'Mitochondria', color: '#16a34a', func: 'Powerhouse of the cell -- generates ATP through cellular respiration. Converts glucose and oxygen into usable energy.', context: 'Mitochondria are especially abundant in muscle cells and neurons, which require large amounts of energy. A single liver cell may contain over 2,000 mitochondria.', shape: 'oval' },
  { id: 'rough_er', name: 'Rough ER', color: '#2563eb', func: 'Studded with ribosomes. Synthesizes and processes proteins destined for membranes, secretion, or lysosomes.', context: 'Cells that secrete large amounts of protein, such as antibody-producing B cells, have extensive rough ER networks.', shape: 'lines' },
  { id: 'smooth_er', name: 'Smooth ER', color: '#0891b2', func: 'Synthesizes lipids, metabolizes carbohydrates, detoxifies drugs and poisons, and stores calcium ions.', context: 'Liver cells have abundant smooth ER for detoxification. Muscle cells use smooth ER (sarcoplasmic reticulum) to store calcium for contraction.', shape: 'lines' },
  { id: 'golgi', name: 'Golgi Apparatus', color: '#d97706', func: 'Modifies, sorts, and packages proteins and lipids for transport to their final destinations inside or outside the cell.', context: 'Goblet cells in the intestinal lining have prominent Golgi complexes for producing mucus that protects the gut lining.', shape: 'stack' },
  { id: 'ribosomes', name: 'Ribosomes', color: '#dc2626', func: 'Translate mRNA into proteins. Can be free in the cytoplasm or bound to the rough ER.', context: 'A single human cell may contain millions of ribosomes. Rapidly dividing cells and cells producing lots of proteins have the most.', shape: 'dots' },
  { id: 'lysosomes', name: 'Lysosomes', color: '#ea580c', func: 'Contain digestive enzymes that break down worn-out organelles, food particles, bacteria, and cellular debris.', context: 'White blood cells (phagocytes) are packed with lysosomes to digest engulfed pathogens. Lysosomal storage diseases occur when specific enzymes are missing.', shape: 'circle' },
  { id: 'cytoskeleton', name: 'Cytoskeleton', color: '#64748b', func: 'Network of protein filaments that provides structural support, enables cell movement, and facilitates intracellular transport.', context: 'The cytoskeleton is critical for cell division (forming the mitotic spindle), muscle contraction (actin and myosin), and nerve cell shape (neurofilaments).', shape: 'web' },
  { id: 'membrane', name: 'Cell Membrane', color: '#be185d', func: 'Selectively permeable phospholipid bilayer that controls what enters and exits the cell. Contains receptors for cell signaling.', context: 'The membrane of a typical human cell contains about 10 billion lipid molecules. Membrane proteins serve as channels, receptors, and enzymes.', shape: 'border' },
  { id: 'centrioles', name: 'Centrioles', color: '#9333ea', func: 'Paired cylindrical structures made of microtubules. Organize the mitotic spindle during cell division and help form cilia and flagella.', context: 'Centrioles are absent in most plant cells. In human cells, they are essential for cell division and are found near the nucleus.', shape: 'pair' }
];

let exploredOrganelles = new Set();
let hoveredOrganelle = null;

// Organelle positions (relative to canvas: x%, y%, radius or w/h)
function getOrganellePositions(W, H) {
  const cx = W * 0.5, cy = H * 0.5;
  const rCell = Math.min(W, H) * 0.42;
  return {
    nucleus:     { x: cx, y: cy, r: rCell * 0.22 },
    mitochondria:{ x: cx + rCell*0.45, y: cy - rCell*0.25, r: rCell * 0.1 },
    rough_er:    { x: cx - rCell*0.15, y: cy - rCell*0.35, r: rCell * 0.15 },
    smooth_er:   { x: cx + rCell*0.15, y: cy + rCell*0.35, r: rCell * 0.13 },
    golgi:       { x: cx - rCell*0.42, y: cy + rCell*0.1, r: rCell * 0.12 },
    ribosomes:   { x: cx - rCell*0.3, y: cy - rCell*0.15, r: rCell * 0.08 },
    lysosomes:   { x: cx + rCell*0.35, y: cy + rCell*0.25, r: rCell * 0.07 },
    cytoskeleton:{ x: cx + rCell*0.05, y: cy + rCell*0.55, r: rCell * 0.1 },
    membrane:    { x: cx, y: cy, r: rCell },
    centrioles:  { x: cx + rCell*0.15, y: cy - rCell*0.08, r: rCell * 0.06 }
  };
}

function drawCellExplorer() {
  const ctx = getCtx('cell-explorer');
  const W = ctx.W, H = ctx.H;
  const cx = W * 0.5, cy = H * 0.5;
  const rCell = Math.min(W, H) * 0.42;

  ctx.clearRect(0, 0, W, H);
  // Background
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const pos = getOrganellePositions(W, H);

  // -- Cell membrane --
  ctx.save();
  const memGrad = ctx.createRadialGradient(cx, cy, rCell * 0.85, cx, cy, rCell);
  memGrad.addColorStop(0, 'rgba(255,240,245,0.3)');
  memGrad.addColorStop(0.7, 'rgba(255,228,235,0.5)');
  memGrad.addColorStop(1, 'rgba(190,24,93,0.15)');
  ctx.fillStyle = memGrad;
  ctx.beginPath(); ctx.arc(cx, cy, rCell, 0, Math.PI * 2); ctx.fill();

  // Membrane double line
  ctx.strokeStyle = hoveredOrganelle === 'membrane' ? '#c41e3a' : '#be185d';
  ctx.lineWidth = hoveredOrganelle === 'membrane' ? 5 : 3;
  ctx.beginPath(); ctx.arc(cx, cy, rCell, 0, Math.PI * 2); ctx.stroke();
  ctx.strokeStyle = hoveredOrganelle === 'membrane' ? '#e8354f' : 'rgba(190,24,93,0.4)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(cx, cy, rCell - 5, 0, Math.PI * 2); ctx.stroke();
  ctx.restore();

  // -- Cytoplasm texture (subtle dots) --
  ctx.save();
  ctx.globalAlpha = 0.05;
  for (let i = 0; i < 200; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * rCell * 0.9;
    const px = cx + Math.cos(angle) * dist;
    const py = cy + Math.sin(angle) * dist;
    ctx.fillStyle = '#374151';
    ctx.beginPath(); ctx.arc(px, py, 1, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();

  // -- Cytoskeleton (filament network) --
  ctx.save();
  const csPos = pos.cytoskeleton;
  ctx.strokeStyle = hoveredOrganelle === 'cytoskeleton' ? '#374151' : '#94a3b8';
  ctx.lineWidth = hoveredOrganelle === 'cytoskeleton' ? 2 : 1;
  ctx.globalAlpha = hoveredOrganelle === 'cytoskeleton' ? 0.7 : 0.3;
  for (let i = 0; i < 12; i++) {
    const a1 = Math.random() * Math.PI * 2;
    const a2 = a1 + (Math.random() - 0.5) * 2;
    const d1 = rCell * (0.2 + Math.random() * 0.6);
    const d2 = rCell * (0.2 + Math.random() * 0.6);
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(a1) * d1, cy + Math.sin(a1) * d1);
    ctx.lineTo(cx + Math.cos(a2) * d2, cy + Math.sin(a2) * d2);
    ctx.stroke();
  }
  ctx.restore();

  // -- Smooth ER --
  const serPos = pos.smooth_er;
  ctx.save();
  ctx.strokeStyle = hoveredOrganelle === 'smooth_er' ? '#0891b2' : 'rgba(8,145,178,0.6)';
  ctx.lineWidth = hoveredOrganelle === 'smooth_er' ? 3 : 2;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    const yOff = serPos.y - serPos.r + (i / 4) * serPos.r * 2;
    ctx.moveTo(serPos.x - serPos.r, yOff);
    ctx.bezierCurveTo(
      serPos.x - serPos.r * 0.3, yOff - 8,
      serPos.x + serPos.r * 0.3, yOff + 8,
      serPos.x + serPos.r, yOff
    );
    ctx.stroke();
  }
  ctx.restore();

  // -- Rough ER --
  const rerPos = pos.rough_er;
  ctx.save();
  ctx.strokeStyle = hoveredOrganelle === 'rough_er' ? '#2563eb' : 'rgba(37,99,235,0.6)';
  ctx.lineWidth = hoveredOrganelle === 'rough_er' ? 3 : 2;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    const yOff = rerPos.y - rerPos.r + (i / 4) * rerPos.r * 2;
    ctx.moveTo(rerPos.x - rerPos.r, yOff);
    ctx.bezierCurveTo(
      rerPos.x - rerPos.r * 0.3, yOff - 6,
      rerPos.x + rerPos.r * 0.3, yOff + 6,
      rerPos.x + rerPos.r, yOff
    );
    ctx.stroke();
    // Ribosomes on rough ER
    for (let j = 0; j < 6; j++) {
      const t = j / 5;
      const rx = rerPos.x - rerPos.r + t * rerPos.r * 2;
      const ry = yOff + Math.sin(t * Math.PI) * 4 - 4;
      ctx.fillStyle = '#dc2626';
      ctx.beginPath(); ctx.arc(rx, ry, 2, 0, Math.PI * 2); ctx.fill();
    }
  }
  ctx.restore();

  // -- Golgi Apparatus --
  const gPos = pos.golgi;
  ctx.save();
  ctx.strokeStyle = hoveredOrganelle === 'golgi' ? '#d97706' : 'rgba(217,119,6,0.7)';
  ctx.fillStyle = hoveredOrganelle === 'golgi' ? 'rgba(217,119,6,0.15)' : 'rgba(217,119,6,0.08)';
  ctx.lineWidth = hoveredOrganelle === 'golgi' ? 3 : 2;
  for (let i = 0; i < 5; i++) {
    const curve = gPos.r * (0.5 + i * 0.15);
    ctx.beginPath();
    ctx.arc(gPos.x, gPos.y, curve, -0.8, 0.8);
    ctx.stroke();
  }
  // Vesicles budding off
  for (let i = 0; i < 3; i++) {
    const vx = gPos.x + gPos.r * 1.2 + i * 10;
    const vy = gPos.y - 5 + i * 12;
    ctx.fillStyle = 'rgba(217,119,6,0.3)';
    ctx.beginPath(); ctx.arc(vx, vy, 4, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = 'rgba(217,119,6,0.6)'; ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.restore();

  // -- Mitochondria --
  const mPos = pos.mitochondria;
  ctx.save();
  ctx.fillStyle = hoveredOrganelle === 'mitochondria' ? 'rgba(22,163,74,0.3)' : 'rgba(22,163,74,0.15)';
  ctx.strokeStyle = hoveredOrganelle === 'mitochondria' ? '#16a34a' : 'rgba(22,163,74,0.7)';
  ctx.lineWidth = hoveredOrganelle === 'mitochondria' ? 3 : 2;
  // Draw bean shape
  ctx.beginPath();
  ctx.ellipse(mPos.x, mPos.y, mPos.r * 1.8, mPos.r, -0.3, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();
  // Inner cristae
  ctx.strokeStyle = hoveredOrganelle === 'mitochondria' ? '#16a34a' : 'rgba(22,163,74,0.5)';
  ctx.lineWidth = 1.5;
  for (let i = 0; i < 4; i++) {
    const fx = mPos.x - mPos.r * 1.2 + (i + 0.5) * mPos.r * 0.7;
    ctx.beginPath();
    ctx.moveTo(fx, mPos.y - mPos.r * 0.7);
    ctx.bezierCurveTo(fx + 5, mPos.y - mPos.r * 0.2, fx - 5, mPos.y + mPos.r * 0.2, fx, mPos.y + mPos.r * 0.5);
    ctx.stroke();
  }
  // Second mitochondrion
  ctx.fillStyle = hoveredOrganelle === 'mitochondria' ? 'rgba(22,163,74,0.25)' : 'rgba(22,163,74,0.1)';
  ctx.beginPath();
  ctx.ellipse(mPos.x - mPos.r * 1.5, mPos.y + mPos.r * 1.8, mPos.r * 1.3, mPos.r * 0.7, 0.5, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();
  ctx.restore();

  // -- Lysosomes --
  const lPos = pos.lysosomes;
  ctx.save();
  ctx.fillStyle = hoveredOrganelle === 'lysosomes' ? 'rgba(234,88,12,0.35)' : 'rgba(234,88,12,0.2)';
  ctx.strokeStyle = hoveredOrganelle === 'lysosomes' ? '#ea580c' : 'rgba(234,88,12,0.6)';
  ctx.lineWidth = hoveredOrganelle === 'lysosomes' ? 2.5 : 1.5;
  ctx.beginPath(); ctx.arc(lPos.x, lPos.y, lPos.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  // Second lysosome
  ctx.beginPath(); ctx.arc(lPos.x + lPos.r * 2.5, lPos.y - lPos.r, lPos.r * 0.7, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  // Enzyme dots inside
  ctx.fillStyle = 'rgba(234,88,12,0.5)';
  for (let i = 0; i < 4; i++) {
    const a = (i / 4) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(lPos.x + Math.cos(a) * lPos.r * 0.4, lPos.y + Math.sin(a) * lPos.r * 0.4, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // -- Free Ribosomes --
  const ribPos = pos.ribosomes;
  ctx.save();
  ctx.fillStyle = hoveredOrganelle === 'ribosomes' ? '#dc2626' : 'rgba(220,38,38,0.5)';
  const ribPositions = [
    [0, 0], [1, -0.5], [-0.8, 0.6], [0.5, 0.8], [-0.3, -0.8],
    [1.2, 0.3], [-1, -0.3], [0.2, 1.2], [-0.5, 0.2], [0.8, -0.8],
    [1.5, -0.2], [-1.3, 0.8], [0.3, -1.3]
  ];
  ribPositions.forEach(([dx, dy]) => {
    ctx.beginPath();
    ctx.arc(ribPos.x + dx * ribPos.r * 1.5, ribPos.y + dy * ribPos.r * 1.5, hoveredOrganelle === 'ribosomes' ? 3.5 : 2.5, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.restore();

  // -- Centrioles --
  const cenPos = pos.centrioles;
  ctx.save();
  ctx.strokeStyle = hoveredOrganelle === 'centrioles' ? '#9333ea' : 'rgba(147,51,234,0.6)';
  ctx.lineWidth = hoveredOrganelle === 'centrioles' ? 2.5 : 1.5;
  // Two perpendicular cylinders
  ctx.beginPath();
  ctx.rect(cenPos.x - cenPos.r, cenPos.y - cenPos.r * 0.3, cenPos.r * 2, cenPos.r * 0.6);
  ctx.stroke();
  // Cross-section lines
  for (let i = 0; i < 4; i++) {
    const lx = cenPos.x - cenPos.r + (i + 0.5) * cenPos.r * 0.5;
    ctx.beginPath();
    ctx.moveTo(lx, cenPos.y - cenPos.r * 0.3);
    ctx.lineTo(lx, cenPos.y + cenPos.r * 0.3);
    ctx.stroke();
  }
  // Second centriole at angle
  ctx.save();
  ctx.translate(cenPos.x, cenPos.y);
  ctx.rotate(Math.PI / 2);
  ctx.beginPath();
  ctx.rect(-cenPos.r * 0.8, -cenPos.r * 0.25, cenPos.r * 1.6, cenPos.r * 0.5);
  ctx.stroke();
  ctx.restore();
  ctx.restore();

  // -- Nucleus --
  const nPos = pos.nucleus;
  ctx.save();
  const nucGrad = ctx.createRadialGradient(nPos.x - nPos.r * 0.2, nPos.y - nPos.r * 0.2, 0, nPos.x, nPos.y, nPos.r);
  nucGrad.addColorStop(0, hoveredOrganelle === 'nucleus' ? 'rgba(124,58,237,0.35)' : 'rgba(124,58,237,0.2)');
  nucGrad.addColorStop(1, hoveredOrganelle === 'nucleus' ? 'rgba(124,58,237,0.15)' : 'rgba(124,58,237,0.08)');
  ctx.fillStyle = nucGrad;
  ctx.strokeStyle = hoveredOrganelle === 'nucleus' ? '#7c3aed' : 'rgba(124,58,237,0.7)';
  ctx.lineWidth = hoveredOrganelle === 'nucleus' ? 3.5 : 2.5;
  ctx.beginPath(); ctx.arc(nPos.x, nPos.y, nPos.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  // Nuclear envelope (double line)
  ctx.strokeStyle = hoveredOrganelle === 'nucleus' ? 'rgba(124,58,237,0.6)' : 'rgba(124,58,237,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(nPos.x, nPos.y, nPos.r - 4, 0, Math.PI * 2); ctx.stroke();
  // Nucleolus
  ctx.fillStyle = hoveredOrganelle === 'nucleus' ? 'rgba(124,58,237,0.5)' : 'rgba(124,58,237,0.3)';
  ctx.beginPath(); ctx.arc(nPos.x + nPos.r * 0.25, nPos.y - nPos.r * 0.15, nPos.r * 0.25, 0, Math.PI * 2); ctx.fill();
  // Chromatin threads
  ctx.strokeStyle = 'rgba(124,58,237,0.25)'; ctx.lineWidth = 1;
  for (let i = 0; i < 6; i++) {
    const a = (i / 6) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(nPos.x + Math.cos(a) * nPos.r * 0.3, nPos.y + Math.sin(a) * nPos.r * 0.3);
    ctx.bezierCurveTo(
      nPos.x + Math.cos(a + 0.5) * nPos.r * 0.6,
      nPos.y + Math.sin(a + 0.5) * nPos.r * 0.6,
      nPos.x + Math.cos(a + 1) * nPos.r * 0.5,
      nPos.y + Math.sin(a + 1) * nPos.r * 0.5,
      nPos.x + Math.cos(a + 1.2) * nPos.r * 0.7,
      nPos.y + Math.sin(a + 1.2) * nPos.r * 0.7
    );
    ctx.stroke();
  }
  ctx.restore();

  // -- Labels --
  ctx.save();
  ctx.font = 'bold 11px system-ui';
  ctx.textAlign = 'center';
  const labelPositions = {
    nucleus: { x: nPos.x, y: nPos.y + nPos.r + 16 },
    mitochondria: { x: mPos.x + mPos.r * 0.5, y: mPos.y - mPos.r - 8 },
    rough_er: { x: rerPos.x, y: rerPos.y - rerPos.r - 8 },
    smooth_er: { x: serPos.x, y: serPos.y + serPos.r + 16 },
    golgi: { x: gPos.x - gPos.r * 0.5, y: gPos.y - gPos.r - 8 },
    ribosomes: { x: ribPos.x - ribPos.r * 2, y: ribPos.y + ribPos.r * 2 },
    lysosomes: { x: lPos.x + lPos.r * 2, y: lPos.y + lPos.r + 16 },
    cytoskeleton: { x: cx + rCell * 0.05, y: cy + rCell * 0.7 },
    membrane: { x: cx + rCell * 0.6, y: cy - rCell * 0.8 },
    centrioles: { x: cenPos.x + cenPos.r * 3, y: cenPos.y }
  };

  organelleData.forEach(org => {
    const lp = labelPositions[org.id];
    const isHover = hoveredOrganelle === org.id;
    const isExplored = exploredOrganelles.has(org.id);
    ctx.fillStyle = isHover ? org.color : (isExplored ? org.color : '#6b7280');
    ctx.font = isHover ? 'bold 12px system-ui' : 'bold 11px system-ui';
    ctx.fillText(org.name, lp.x, lp.y);
    if (isExplored) {
      ctx.fillStyle = '#16a34a';
      ctx.font = '10px system-ui';
      ctx.fillText('  \u2713', lp.x + ctx.measureText(org.name).width / 2 + 2, lp.y);
    }
  });
  ctx.restore();
}

function hitTestOrganelle(mx, my) {
  const c = $('cell-explorer');
  const W = c.offsetWidth, H = c.offsetHeight || 480;
  const pos = getOrganellePositions(W, H);

  // Test from smallest to largest (more specific first), membrane last
  const order = ['centrioles','lysosomes','ribosomes','mitochondria','rough_er','smooth_er','golgi','cytoskeleton','nucleus','membrane'];
  for (const id of order) {
    const p = pos[id];
    const dx = mx - p.x, dy = my - p.y;
    let hitR = p.r;
    if (id === 'mitochondria') hitR = p.r * 2;
    if (id === 'rough_er' || id === 'smooth_er') hitR = p.r * 1.3;
    if (id === 'golgi') hitR = p.r * 1.5;
    if (id === 'cytoskeleton') hitR = p.r * 1.5;
    if (id === 'membrane') {
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > p.r * 0.88 && dist < p.r * 1.05) return id;
      continue;
    }
    if (dx * dx + dy * dy < hitR * hitR) return id;
  }
  return null;
}

function setupCellExplorer() {
  const c = $('cell-explorer');
  c.addEventListener('mousemove', e => {
    const rect = c.getBoundingClientRect();
    const scaleX = c.offsetWidth / c.offsetWidth;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleX;
    const hit = hitTestOrganelle(mx, my);
    if (hit !== hoveredOrganelle) {
      hoveredOrganelle = hit;
      c.style.cursor = hit ? 'pointer' : 'default';
      drawCellExplorer();
    }
  });
  c.addEventListener('mouseleave', () => {
    hoveredOrganelle = null;
    drawCellExplorer();
  });
  c.addEventListener('click', e => {
    const rect = c.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const hit = hitTestOrganelle(mx, my);
    if (hit) {
      exploredOrganelles.add(hit);
      const org = organelleData.find(o => o.id === hit);
      $('explorer-info').innerHTML = `
        <div class="ip-title">${org.name}</div>
        <div class="ip-function">${org.func}</div>
        <div class="ip-context">${org.context}</div>`;
      $('exp-clicked').textContent = exploredOrganelles.size;
      $('exp-pct').textContent = Math.round(exploredOrganelles.size / organelleData.length * 100) + '%';
      drawCellExplorer();
    }
  });
}


// ══════════════════════════════════════════════════════════════════════════
// PART 2: MICROSCOPE SIMULATOR
// ══════════════════════════════════════════════════════════════════════════
let currentSlide = 'cheek';
let currentMag = 40;

const slideInfo = {
  cheek: {
    name: 'Cheek Epithelial',
    type: 'Animal',
    info: {
      40: { title: 'Cheek Epithelial Cells -- 40x', func: 'At low power, you see clusters of flat, irregularly shaped cells. These squamous epithelial cells were scraped from the inner lining of the cheek.', context: 'Animal cells: no cell wall, no chloroplasts. The thin cell membrane is barely visible at this magnification.' },
      100: { title: 'Cheek Epithelial Cells -- 100x', func: 'At medium power, individual cells become clearer. The nucleus appears as a dark spot near the center. The cytoplasm appears granular and slightly transparent.', context: 'Notice the irregular cell shape -- animal cells are flexible because they lack a rigid cell wall.' },
      400: { title: 'Cheek Epithelial Cells -- 400x', func: 'At high power, the nucleus is prominent with a darker nucleolus visible. The cell membrane boundary is thin. You can see the granular cytoplasm containing organelles too small to resolve with light microscopy.', context: 'Key animal cell features visible: nucleus, cell membrane, cytoplasm. No cell wall or chloroplasts are present.' }
    }
  },
  blood: {
    name: 'Blood Smear',
    type: 'Animal',
    info: {
      40: { title: 'Blood Smear -- 40x', func: 'At low power, you see a pink-red field with countless small dots. These are red blood cells (erythrocytes) spread across the slide in a thin layer.', context: 'Blood contains multiple cell types. Red blood cells are the most numerous, forming the dominant visual field.' },
      100: { title: 'Blood Smear -- 100x', func: 'At medium power, individual red blood cells become visible as pale pink discs. Occasional larger, darker cells are white blood cells (leukocytes).', context: 'Red blood cells are unique -- they lack a nucleus in their mature form to make room for more hemoglobin.' },
      400: { title: 'Blood Smear -- 400x', func: 'At high power, the biconcave disc shape of red blood cells is visible as a lighter center. White blood cells show dark, lobed nuclei. Tiny platelet fragments may be visible between cells.', context: 'The biconcave shape increases surface area for gas exchange. RBCs are about 7-8 micrometers in diameter.' }
    }
  },
  onion: {
    name: 'Onion Epidermis',
    type: 'Plant',
    info: {
      40: { title: 'Onion Epidermis -- 40x', func: 'At low power, you see a brick-like pattern of rectangular cells arranged in neat rows. This is the single-cell-thick layer peeled from an onion scale.', context: 'Plant cells: rigid cell wall gives the characteristic rectangular shape. No chloroplasts in onion epidermis (it is underground).' },
      100: { title: 'Onion Epidermis -- 100x', func: 'At medium power, the thick cell walls are clearly visible between cells. Each cell shows a nucleus pressed against the cell wall. A large central vacuole takes up most of the cell interior.', context: 'Compare to cheek cells: onion cells have thick cell walls and are rectangular, while cheek cells are irregular and flexible.' },
      400: { title: 'Onion Epidermis -- 400x', func: 'At high power, the cell wall appears as a thick double line between adjacent cells. The nucleus is clearly visible. The large central vacuole pushes the cytoplasm to a thin layer along the cell wall.', context: 'Key plant cell features visible: cell wall (thick, rigid), large central vacuole, nucleus. No chloroplasts (non-photosynthetic tissue).' }
    }
  }
};

function setSlide(s) { currentSlide = s; drawMicroscope(); updateMicroInfo(); }
function setMag(m) { currentMag = m; drawMicroscope(); updateMicroInfo(); }

function updateMicroInfo() {
  const info = slideInfo[currentSlide].info[currentMag];
  $('micro-slide').textContent = slideInfo[currentSlide].name;
  $('micro-mag').textContent = currentMag + 'x';
  $('micro-type').textContent = slideInfo[currentSlide].type;
  $('micro-info').innerHTML = `
    <div class="ip-title">${info.title}</div>
    <div class="ip-function">${info.func}</div>
    <div class="ip-context">${info.context}</div>`;
}

function drawMicroscope() {
  const ctx = getCtx('microscope-canvas');
  const W = ctx.W, H = ctx.H;
  const cx = W / 2, cy = H / 2;
  const viewR = Math.min(W, H) * 0.44;

  ctx.clearRect(0, 0, W, H);
  // Dark surround
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, 0, W, H);

  // Clip to circular field of view
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, viewR, 0, Math.PI * 2);
  ctx.clip();

  // Light background
  ctx.fillStyle = '#fefefe';
  ctx.fillRect(0, 0, W, H);

  if (currentSlide === 'cheek') drawCheekCells(ctx, cx, cy, viewR);
  else if (currentSlide === 'blood') drawBloodCells(ctx, cx, cy, viewR);
  else if (currentSlide === 'onion') drawOnionCells(ctx, cx, cy, viewR);

  ctx.restore();

  // Circular border
  ctx.strokeStyle = '#374151';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(cx, cy, viewR, 0, Math.PI * 2);
  ctx.stroke();

  // Vignette
  const vig = ctx.createRadialGradient(cx, cy, viewR * 0.7, cx, cy, viewR);
  vig.addColorStop(0, 'transparent');
  vig.addColorStop(1, 'rgba(0,0,0,0.3)');
  ctx.fillStyle = vig;
  ctx.beginPath();
  ctx.arc(cx, cy, viewR, 0, Math.PI * 2);
  ctx.fill();

  // Magnification label
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'right';
  ctx.fillText(currentMag + 'x', W - 20, H - 16);
}

function drawCheekCells(ctx, cx, cy, viewR) {
  const scale = currentMag / 40;
  const cellSize = 30 * scale;
  const numCells = Math.round(12 / scale);

  // Seed-based positions for consistency
  const cells = [];
  for (let i = 0; i < numCells * numCells; i++) {
    const gx = (i % numCells) - numCells / 2;
    const gy = Math.floor(i / numCells) - numCells / 2;
    const x = cx + gx * cellSize * 1.6 + (Math.sin(i * 3.7) * cellSize * 0.4);
    const y = cy + gy * cellSize * 1.4 + (Math.cos(i * 2.3) * cellSize * 0.3);
    if (Math.hypot(x - cx, y - cy) < viewR * 0.95) {
      cells.push({ x, y, size: cellSize * (0.8 + Math.sin(i) * 0.3) });
    }
  }

  cells.forEach((cell, i) => {
    // Cell body
    ctx.fillStyle = `rgba(255,220,220,${0.3 + Math.sin(i * 1.3) * 0.1})`;
    ctx.strokeStyle = 'rgba(200,150,150,0.5)';
    ctx.lineWidth = scale > 5 ? 2 : 1;
    ctx.beginPath();
    // Irregular shape
    for (let a = 0; a < Math.PI * 2; a += 0.3) {
      const r = cell.size * (0.8 + Math.sin(a * 3 + i) * 0.2);
      const px = cell.x + Math.cos(a) * r;
      const py = cell.y + Math.sin(a) * r;
      a === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Nucleus (visible at higher mag)
    if (currentMag >= 100) {
      ctx.fillStyle = 'rgba(120,50,120,0.4)';
      ctx.beginPath();
      ctx.arc(cell.x + cell.size * 0.1, cell.y - cell.size * 0.05, cell.size * 0.25, 0, Math.PI * 2);
      ctx.fill();
      if (currentMag >= 400) {
        // Nucleolus
        ctx.fillStyle = 'rgba(80,20,80,0.5)';
        ctx.beginPath();
        ctx.arc(cell.x + cell.size * 0.15, cell.y - cell.size * 0.08, cell.size * 0.08, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  });

  // Labels at high mag
  if (currentMag >= 400 && cells.length > 0) {
    ctx.fillStyle = '#374151';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'left';
    const c0 = cells[0];
    drawLabel(ctx, c0.x + c0.size * 0.5, c0.y - c0.size * 0.3, 'Nucleus', c0.x + c0.size, c0.y - c0.size * 0.8);
    drawLabel(ctx, c0.x - c0.size * 0.8, c0.y, 'Cell Membrane', c0.x - c0.size * 1.5, c0.y - c0.size * 0.5);
  }
}

function drawBloodCells(ctx, cx, cy, viewR) {
  const scale = currentMag / 40;
  const rbcSize = 4 * scale;
  const numRBC = Math.round(200 / (scale * scale));

  // RBCs
  for (let i = 0; i < numRBC; i++) {
    const angle = (i / numRBC) * Math.PI * 47 + i * 0.618;
    const dist = Math.sqrt(i / numRBC) * viewR * 0.9;
    const x = cx + Math.cos(angle) * dist + Math.sin(i * 7.3) * rbcSize * 2;
    const y = cy + Math.sin(angle) * dist + Math.cos(i * 5.1) * rbcSize * 2;

    if (Math.hypot(x - cx, y - cy) > viewR) continue;

    // Biconcave disc
    ctx.fillStyle = `rgba(240,180,180,${0.6 + Math.sin(i) * 0.2})`;
    ctx.strokeStyle = 'rgba(200,100,100,0.4)';
    ctx.lineWidth = scale > 5 ? 1.5 : 0.5;
    ctx.beginPath();
    ctx.arc(x, y, rbcSize, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Lighter center (biconcave)
    if (currentMag >= 100) {
      ctx.fillStyle = 'rgba(255,220,220,0.5)';
      ctx.beginPath();
      ctx.arc(x, y, rbcSize * 0.35, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // WBCs (a few larger cells)
  const wbcCount = Math.max(1, Math.round(3 / scale));
  for (let i = 0; i < wbcCount; i++) {
    const x = cx + Math.cos(i * 2.5) * viewR * 0.4;
    const y = cy + Math.sin(i * 3.2) * viewR * 0.3;
    const wbcSize = rbcSize * 2;

    ctx.fillStyle = 'rgba(220,220,240,0.6)';
    ctx.strokeStyle = 'rgba(100,100,180,0.5)';
    ctx.lineWidth = scale > 3 ? 2 : 1;
    ctx.beginPath();
    ctx.arc(x, y, wbcSize, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Lobed nucleus at higher mag
    if (currentMag >= 100) {
      ctx.fillStyle = 'rgba(60,40,120,0.5)';
      for (let l = 0; l < 3; l++) {
        const la = (l / 3) * Math.PI * 2 + 0.5;
        ctx.beginPath();
        ctx.arc(x + Math.cos(la) * wbcSize * 0.3, y + Math.sin(la) * wbcSize * 0.3, wbcSize * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  if (currentMag >= 400) {
    ctx.fillStyle = '#374151'; ctx.font = 'bold 10px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Red Blood Cell', cx + viewR * 0.5, cy - viewR * 0.4);
    ctx.fillText('White Blood Cell', cx - viewR * 0.4, cy + viewR * 0.3);
  }
}

function drawOnionCells(ctx, cx, cy, viewR) {
  const scale = currentMag / 40;
  const cellW = 60 * scale;
  const cellH = 30 * scale;
  const cols = Math.round(8 / scale);
  const rows = Math.round(14 / scale);

  for (let r = -rows; r <= rows; r++) {
    for (let c = -cols; c <= cols; c++) {
      const x = cx + c * cellW;
      const y = cy + r * cellH + (c % 2 === 0 ? cellH * 0.3 : 0);

      if (Math.hypot(x - cx, y - cy) > viewR * 0.95) continue;

      // Cell wall
      ctx.strokeStyle = 'rgba(50,120,50,0.6)';
      ctx.lineWidth = scale > 3 ? 3 : (scale > 1 ? 2 : 1);
      ctx.fillStyle = 'rgba(220,245,220,0.3)';
      ctx.fillRect(x - cellW / 2, y - cellH / 2, cellW, cellH);
      ctx.strokeRect(x - cellW / 2, y - cellH / 2, cellW, cellH);

      // Large central vacuole
      if (currentMag >= 100) {
        ctx.fillStyle = 'rgba(200,230,255,0.2)';
        ctx.fillRect(x - cellW * 0.35, y - cellH * 0.35, cellW * 0.7, cellH * 0.7);
      }

      // Nucleus
      if (currentMag >= 100) {
        ctx.fillStyle = 'rgba(80,50,120,0.35)';
        ctx.beginPath();
        ctx.arc(x + cellW * 0.25, y, cellH * 0.2, 0, Math.PI * 2);
        ctx.fill();

        if (currentMag >= 400) {
          // Nucleolus
          ctx.fillStyle = 'rgba(50,20,80,0.4)';
          ctx.beginPath();
          ctx.arc(x + cellW * 0.27, y - cellH * 0.05, cellH * 0.07, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  if (currentMag >= 400) {
    ctx.fillStyle = '#374151'; ctx.font = 'bold 10px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Cell Wall', cx - viewR * 0.3, cy - viewR * 0.5);
    ctx.fillText('Nucleus', cx + viewR * 0.35, cy - viewR * 0.2);
    ctx.fillText('Central Vacuole', cx, cy + viewR * 0.4);
  }
}

function drawLabel(ctx, fromX, fromY, text, toX, toY) {
  ctx.save();
  ctx.strokeStyle = '#6b7280';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();
  ctx.fillStyle = '#374151';
  ctx.font = 'bold 11px system-ui';
  ctx.textAlign = toX < fromX ? 'right' : 'left';
  ctx.fillText(text, toX + (toX < fromX ? -4 : 4), toY - 4);
  ctx.restore();
}


// ══════════════════════════════════════════════════════════════════════════
// PART 3: CELL TYPE COMPARISON
// ══════════════════════════════════════════════════════════════════════════
const compFeatures = [
  { feature: 'Cell Membrane', prokaryote: true, animal: true, plant: true },
  { feature: 'Cell Wall', prokaryote: true, animal: false, plant: true },
  { feature: 'Nucleus (membrane-bound)', prokaryote: false, animal: true, plant: true },
  { feature: 'DNA', prokaryote: true, animal: true, plant: true },
  { feature: 'Ribosomes', prokaryote: true, animal: true, plant: true },
  { feature: 'Mitochondria', prokaryote: false, animal: true, plant: true },
  { feature: 'Endoplasmic Reticulum', prokaryote: false, animal: true, plant: true },
  { feature: 'Golgi Apparatus', prokaryote: false, animal: true, plant: true },
  { feature: 'Lysosomes', prokaryote: false, animal: true, plant: false },
  { feature: 'Chloroplasts', prokaryote: false, animal: false, plant: true },
  { feature: 'Large Central Vacuole', prokaryote: false, animal: false, plant: true },
  { feature: 'Centrioles', prokaryote: false, animal: true, plant: false },
  { feature: 'Flagella/Cilia', prokaryote: true, animal: true, plant: false },
];

function buildCompGrid() {
  const g = $('compare-grid');
  g.innerHTML = '';
  // Headers
  ['Feature', 'Prokaryote', 'Animal Cell', 'Plant Cell'].forEach(t => {
    const d = document.createElement('div');
    d.className = 'tg-cell tg-header';
    d.textContent = t;
    g.appendChild(d);
  });

  compFeatures.forEach((feat, i) => {
    // Feature label
    const lbl = document.createElement('div');
    lbl.className = 'tg-cell tg-label';
    lbl.textContent = feat.feature;
    g.appendChild(lbl);

    ['prokaryote', 'animal', 'plant'].forEach(type => {
      const cell = document.createElement('div');
      const val = feat[type];
      cell.className = 'tg-cell ' + (val ? 'tg-on' : 'tg-off');
      cell.textContent = val ? 'Present' : 'Absent';
      cell.onclick = () => {
        feat[type] = !feat[type];
        cell.className = 'tg-cell ' + (feat[type] ? 'tg-on' : 'tg-off');
        cell.textContent = feat[type] ? 'Present' : 'Absent';
        drawVenn();
      };
      g.appendChild(cell);
    });
  });
}

function drawSizeScale() {
  const ctx = getCtx('size-scale-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const pad = { left: 60, right: 40, top: 30, bottom: 40 };
  const plotW = W - pad.left - pad.right;

  // Scale bar
  const maxUM = 120; // micrometers
  ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(pad.left, H - pad.bottom);
  ctx.lineTo(W - pad.right, H - pad.bottom);
  ctx.stroke();

  // Tick marks
  ctx.font = '11px system-ui'; ctx.textAlign = 'center'; ctx.fillStyle = '#374151';
  for (let um = 0; um <= maxUM; um += 20) {
    const x = pad.left + (um / maxUM) * plotW;
    ctx.beginPath(); ctx.moveTo(x, H - pad.bottom); ctx.lineTo(x, H - pad.bottom + 6); ctx.stroke();
    ctx.fillText(um + ' \u03BCm', x, H - pad.bottom + 20);
  }

  // Cells to scale
  const cells = [
    { name: 'Bacterium', size: 1, color: '#dc2626', y: pad.top + 20 },
    { name: 'Red Blood Cell', size: 8, color: '#ea580c', y: pad.top + 50 },
    { name: 'Human Cell (typical)', size: 20, color: '#2563eb', y: pad.top + 80 },
    { name: 'Plant Cell', size: 75, color: '#16a34a', y: pad.top + 110 }
  ];

  cells.forEach(cell => {
    const w = (cell.size / maxUM) * plotW;
    const x = pad.left;
    ctx.fillStyle = cell.color + '30';
    ctx.strokeStyle = cell.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(x, cell.y - 10, Math.max(w, 4), 20, 4);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = '#374151';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(cell.name + ' (~' + cell.size + ' \u03BCm)', x + Math.max(w, 6) + 8, cell.y + 4);
  });
}

function drawVenn() {
  const ctx = getCtx('venn-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const cy = H * 0.45;
  const r = Math.min(W, H) * 0.28;
  const offset = r * 0.7;

  // Three circles
  const circles = [
    { x: W * 0.5 - offset, y: cy, label: 'Prokaryote', color: 'rgba(220,38,38,0.12)', stroke: '#dc2626' },
    { x: W * 0.5, y: cy - offset * 0.6, label: 'Animal Cell', color: 'rgba(37,99,235,0.12)', stroke: '#2563eb' },
    { x: W * 0.5 + offset, y: cy, label: 'Plant Cell', color: 'rgba(22,163,74,0.12)', stroke: '#16a34a' }
  ];

  circles.forEach(c => {
    ctx.fillStyle = c.color;
    ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = c.stroke; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI * 2); ctx.stroke();
  });

  // Labels
  ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillStyle = '#dc2626'; ctx.fillText('Prokaryote', circles[0].x - r * 0.5, circles[0].y - r * 0.1);
  ctx.fillStyle = '#2563eb'; ctx.fillText('Animal Cell', circles[1].x, circles[1].y - r * 0.6);
  ctx.fillStyle = '#16a34a'; ctx.fillText('Plant Cell', circles[2].x + r * 0.5, circles[2].y - r * 0.1);

  // Categorize features
  const onlyProk = [], onlyAnim = [], onlyPlant = [];
  const prokAnim = [], prokPlant = [], animPlant = [];
  const allThree = [];

  compFeatures.forEach(f => {
    const p = f.prokaryote, a = f.animal, pl = f.plant;
    if (p && a && pl) allThree.push(f.feature);
    else if (p && a && !pl) prokAnim.push(f.feature);
    else if (p && !a && pl) prokPlant.push(f.feature);
    else if (!p && a && pl) animPlant.push(f.feature);
    else if (p && !a && !pl) onlyProk.push(f.feature);
    else if (!p && a && !pl) onlyAnim.push(f.feature);
    else if (!p && !a && pl) onlyPlant.push(f.feature);
  });

  ctx.font = '10px system-ui'; ctx.fillStyle = '#374151';

  // All three (center)
  const centerX = W * 0.5, centerY = cy + 5;
  ctx.font = 'bold 10px system-ui';
  allThree.forEach((f, i) => {
    ctx.fillText(f, centerX, centerY + i * 13 - (allThree.length * 6));
  });

  // Only sections
  ctx.font = '10px system-ui';
  onlyProk.forEach((f, i) => ctx.fillText(f, circles[0].x - r * 0.5, circles[0].y + r * 0.2 + i * 13));
  onlyAnim.forEach((f, i) => ctx.fillText(f, circles[1].x, circles[1].y - r * 0.35 + i * 13));
  onlyPlant.forEach((f, i) => ctx.fillText(f, circles[2].x + r * 0.5, circles[2].y + r * 0.2 + i * 13));

  // Overlapping pairs
  ctx.fillStyle = '#6b7280'; ctx.font = '9px system-ui';
  animPlant.forEach((f, i) => ctx.fillText(f, (circles[1].x + circles[2].x) / 2 + r * 0.15, cy - r * 0.15 + i * 12));
  prokAnim.forEach((f, i) => ctx.fillText(f, (circles[0].x + circles[1].x) / 2 - r * 0.1, cy - r * 0.3 + i * 12));
  prokPlant.forEach((f, i) => ctx.fillText(f, (circles[0].x + circles[2].x) / 2, cy + r * 0.45 + i * 12));
}


// ══════════════════════════════════════════════════════════════════════════
// PART 4: ORGANELLE FUNCTION MATCHING
// ══════════════════════════════════════════════════════════════════════════
const matchPairs = [
  { organelle: 'Nucleus', func: 'Control center -- contains DNA', color: '#7c3aed' },
  { organelle: 'Mitochondria', func: 'Powerhouse -- makes ATP', color: '#16a34a' },
  { organelle: 'Rough ER', func: 'Protein synthesis & processing', color: '#2563eb' },
  { organelle: 'Smooth ER', func: 'Lipid synthesis & detox', color: '#0891b2' },
  { organelle: 'Golgi Apparatus', func: 'Sorting & packaging center', color: '#d97706' },
  { organelle: 'Ribosomes', func: 'Translates mRNA to protein', color: '#dc2626' },
  { organelle: 'Lysosomes', func: 'Digestive enzymes -- recycling', color: '#ea580c' },
  { organelle: 'Cell Membrane', func: 'Selective barrier -- controls entry', color: '#be185d' },
  { organelle: 'Cytoskeleton', func: 'Structural support & transport', color: '#64748b' },
  { organelle: 'Centrioles', func: 'Organizes cell division spindle', color: '#9333ea' },
  { organelle: 'Peroxisomes', func: 'Breaks down fatty acids & H2O2', color: '#059669' },
  { organelle: 'Nucleolus', func: 'Produces ribosomal RNA', color: '#6d28d9' },
];

let matchState = {
  score: 0,
  attempts: 0,
  matched: new Set(),
  functions: [],
  organelles: [],
  dragging: null,
  dragX: 0,
  dragY: 0,
  timerInterval: null,
  timeLeft: 0,
  timed: false,
  positions: { funcs: [], orgs: [] }
};

function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function matchStart() {
  matchState.score = 0;
  matchState.attempts = 0;
  matchState.matched = new Set();
  matchState.timed = false;
  if (matchState.timerInterval) clearInterval(matchState.timerInterval);
  matchState.functions = shuffleArray(matchPairs.map((p, i) => ({ ...p, idx: i })));
  matchState.organelles = shuffleArray(matchPairs.map((p, i) => ({ ...p, idx: i })));
  matchState.dragging = null;
  updateMatchStats();
  drawMatchGame();
}

function matchStartTimed() {
  matchStart();
  matchState.timed = true;
  matchState.timeLeft = 90;
  $('match-timer').textContent = '90s';
  matchState.timerInterval = setInterval(() => {
    matchState.timeLeft--;
    $('match-timer').textContent = matchState.timeLeft + 's';
    if (matchState.timeLeft <= 0) {
      clearInterval(matchState.timerInterval);
      $('match-timer').textContent = 'Time!';
    }
  }, 1000);
}

function matchReset() {
  if (matchState.timerInterval) clearInterval(matchState.timerInterval);
  matchState = { score: 0, attempts: 0, matched: new Set(), functions: [], organelles: [], dragging: null, dragX: 0, dragY: 0, timerInterval: null, timeLeft: 0, timed: false, positions: { funcs: [], orgs: [] } };
  updateMatchStats();
  const ctx = getCtx('match-canvas');
  ctx.clearRect(0, 0, ctx.W, ctx.H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, ctx.W, ctx.H);
  ctx.fillStyle = '#9ca3af'; ctx.font = '14px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Click "New Game" to start matching organelles to their functions', ctx.W / 2, ctx.H / 2);
}

function updateMatchStats() {
  $('match-score').textContent = matchState.score;
  $('match-attempts').textContent = matchState.attempts;
  $('match-accuracy').textContent = matchState.attempts > 0 ? Math.round(matchState.score / matchState.attempts * 100) + '%' : '-';
}

function drawMatchGame() {
  const ctx = getCtx('match-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  if (!matchState.functions.length) return;

  const leftCol = 20;
  const rightCol = W * 0.55;
  const itemH = 40;
  const startY = 10;

  // Title
  ctx.fillStyle = '#374151'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Functions', leftCol + (rightCol - leftCol - 40) / 2, startY + 5);
  ctx.fillText('Organelles', rightCol + (W - rightCol - 20) / 2, startY + 5);

  matchState.positions.funcs = [];
  matchState.positions.orgs = [];

  // Draw function descriptions (left)
  matchState.functions.forEach((f, i) => {
    const y = startY + 20 + i * itemH;
    const w = rightCol - leftCol - 40;
    const isMatched = matchState.matched.has(f.idx);

    ctx.fillStyle = isMatched ? '#f0fdf4' : '#fff';
    ctx.strokeStyle = isMatched ? '#86efac' : '#e5e7eb';
    ctx.lineWidth = isMatched ? 2 : 1;
    ctx.beginPath();
    ctx.roundRect(leftCol, y, w, itemH - 6, 6);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = isMatched ? '#166534' : '#374151';
    ctx.font = isMatched ? 'bold 12px system-ui' : '12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(f.func, leftCol + 10, y + itemH / 2);

    if (isMatched) {
      ctx.fillStyle = '#16a34a'; ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'right';
      ctx.fillText('\u2713', leftCol + w - 8, y + itemH / 2);
    }

    matchState.positions.funcs.push({ x: leftCol, y, w, h: itemH - 6, idx: f.idx });
  });

  // Draw organelle targets (right)
  matchState.organelles.forEach((o, i) => {
    const y = startY + 20 + i * itemH;
    const w = W - rightCol - 20;
    const isMatched = matchState.matched.has(o.idx);

    ctx.fillStyle = isMatched ? '#f0fdf4' : o.color + '15';
    ctx.strokeStyle = isMatched ? '#86efac' : o.color + '80';
    ctx.lineWidth = isMatched ? 2 : 2;
    ctx.beginPath();
    ctx.roundRect(rightCol, y, w, itemH - 6, 6);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = isMatched ? '#166534' : o.color;
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(o.organelle, rightCol + w / 2, y + itemH / 2);

    matchState.positions.orgs.push({ x: rightCol, y, w, h: itemH - 6, idx: o.idx });
  });

  // Draw dragging item
  if (matchState.dragging !== null) {
    const f = matchState.functions[matchState.dragging];
    const w = rightCol - leftCol - 40;
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#fef2f2';
    ctx.strokeStyle = '#c41e3a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(matchState.dragX - w / 2, matchState.dragY - 15, w, itemH - 6, 6);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#c41e3a'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
    ctx.fillText(f.func, matchState.dragX, matchState.dragY + 3);
    ctx.globalAlpha = 1;
  }

  // Win message
  if (matchState.matched.size === matchPairs.length) {
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#16a34a';
    ctx.font = 'bold 28px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('All Matched!', W / 2, H / 2 - 20);
    ctx.font = '16px system-ui'; ctx.fillStyle = '#374151';
    ctx.fillText(`Score: ${matchState.score}/${matchPairs.length}  |  Accuracy: ${Math.round(matchState.score / matchState.attempts * 100)}%`, W / 2, H / 2 + 20);
    if (matchState.timed) {
      ctx.fillText(`Time remaining: ${matchState.timeLeft}s`, W / 2, H / 2 + 45);
    }
    if (matchState.timerInterval) clearInterval(matchState.timerInterval);
  }
}

function setupMatchGame() {
  const c = $('match-canvas');
  let selectedFunc = null;

  c.addEventListener('click', e => {
    if (matchState.timed && matchState.timeLeft <= 0) return;
    if (!matchState.functions.length) return;

    const rect = c.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Check if clicking a function
    for (let i = 0; i < matchState.positions.funcs.length; i++) {
      const p = matchState.positions.funcs[i];
      if (matchState.matched.has(p.idx)) continue;
      if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
        selectedFunc = i;
        // Highlight
        drawMatchGame();
        const ctx = getCtx('match-canvas');
        ctx.strokeStyle = '#c41e3a'; ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(p.x, p.y, p.w, p.h, 6);
        ctx.stroke();
        return;
      }
    }

    // Check if clicking an organelle (to match with selected function)
    if (selectedFunc !== null) {
      for (let i = 0; i < matchState.positions.orgs.length; i++) {
        const p = matchState.positions.orgs[i];
        if (matchState.matched.has(p.idx)) continue;
        if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
          const funcItem = matchState.functions[selectedFunc];
          const orgItem = matchState.organelles[i];
          matchState.attempts++;

          if (funcItem.idx === orgItem.idx) {
            // Correct match
            matchState.score++;
            matchState.matched.add(funcItem.idx);
          }

          selectedFunc = null;
          updateMatchStats();
          drawMatchGame();
          return;
        }
      }
    }
  });
}


// ══════════════════════════════════════════════════════════════════════════
// PART 5: CELL AS FACTORY
// ══════════════════════════════════════════════════════════════════════════
const factoryDepts = [
  { id: 'management', name: 'Management Office', organelle: 'Nucleus', desc: 'The nucleus is like management -- it contains the blueprints (DNA) and directs all cellular activities, just as management makes decisions and holds the company plans.', color: '#7c3aed', x: 0.5, y: 0.15, w: 0.25, h: 0.12 },
  { id: 'assembly', name: 'Assembly Line', organelle: 'Ribosomes', desc: 'Ribosomes are the assembly line workers -- they read the instructions (mRNA) from management and build the products (proteins), one amino acid at a time.', color: '#dc2626', x: 0.15, y: 0.32, w: 0.25, h: 0.12 },
  { id: 'manufacturing', name: 'Manufacturing Floor', organelle: 'Endoplasmic Reticulum', desc: 'The ER is the manufacturing floor -- the rough ER (with ribosomes) handles protein production, while the smooth ER makes lipids and handles other manufacturing tasks.', color: '#2563eb', x: 0.6, y: 0.32, w: 0.28, h: 0.12 },
  { id: 'shipping', name: 'Shipping & Packaging', organelle: 'Golgi Apparatus', desc: 'The Golgi apparatus is the shipping department -- it receives products, packages them, adds labels (modifications), and ships them to the right destination inside or outside the cell.', color: '#d97706', x: 0.15, y: 0.50, w: 0.25, h: 0.12 },
  { id: 'powerplant', name: 'Power Plant', organelle: 'Mitochondria', desc: 'Mitochondria are the power plant -- they convert fuel (glucose) into usable energy (ATP) that powers all factory operations, just like a power station generates electricity.', color: '#16a34a', x: 0.6, y: 0.50, w: 0.25, h: 0.12 },
  { id: 'recycling', name: 'Recycling Center', organelle: 'Lysosomes', desc: 'Lysosomes are the recycling center -- they break down waste materials, worn-out parts, and foreign intruders, recovering useful components and keeping the factory clean.', color: '#ea580c', x: 0.15, y: 0.68, w: 0.25, h: 0.12 },
  { id: 'security', name: 'Security Gate', organelle: 'Cell Membrane', desc: 'The cell membrane is like security -- it controls who and what enters and exits the factory. It has checkpoints (transport proteins) and ID verification (receptors) for selective access.', color: '#be185d', x: 0.6, y: 0.68, w: 0.25, h: 0.12 },
];

let hoveredDept = null;

function drawFactory() {
  const ctx = getCtx('factory-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  // Factory building outline
  const bx = W * 0.05, by = H * 0.05, bw = W * 0.9, bh = H * 0.85;
  ctx.fillStyle = '#fafafa';
  ctx.strokeStyle = '#374151';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 12);
  ctx.fill(); ctx.stroke();

  // Factory roof
  ctx.fillStyle = '#374151';
  ctx.beginPath();
  ctx.moveTo(bx, by);
  ctx.lineTo(bx + bw / 2, by - 25);
  ctx.lineTo(bx + bw, by);
  ctx.closePath();
  ctx.fill();

  // Factory title
  ctx.fillStyle = '#fff'; ctx.font = 'bold 14px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('THE CELL FACTORY', bx + bw / 2, by - 6);

  // Draw departments
  factoryDepts.forEach(dept => {
    const dx = W * dept.x - (W * dept.w / 2);
    const dy = H * dept.y;
    const dw = W * dept.w;
    const dh = H * dept.h;
    const isHover = hoveredDept === dept.id;

    // Department box
    ctx.fillStyle = isHover ? dept.color + '25' : dept.color + '10';
    ctx.strokeStyle = isHover ? dept.color : dept.color + '80';
    ctx.lineWidth = isHover ? 3 : 1.5;
    ctx.beginPath();
    ctx.roundRect(dx, dy, dw, dh, 8);
    ctx.fill(); ctx.stroke();

    // Department icon area
    ctx.fillStyle = dept.color + '20';
    ctx.beginPath();
    ctx.roundRect(dx + 6, dy + 6, 28, dh - 12, 4);
    ctx.fill();

    // Simple icon
    ctx.fillStyle = dept.color;
    ctx.font = 'bold 16px system-ui';
    ctx.textAlign = 'center';
    const icons = { management: '\u2605', assembly: '\u2699', manufacturing: '\u2692', shipping: '\u2709', powerplant: '\u26A1', recycling: '\u267B', security: '\u26E8' };
    ctx.fillText(icons[dept.id] || '\u2022', dx + 20, dy + dh / 2 + 6);

    // Department name
    ctx.fillStyle = dept.color;
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(dept.name, dx + 40, dy + dh * 0.38);

    // Organelle name
    ctx.fillStyle = '#6b7280';
    ctx.font = '11px system-ui';
    ctx.fillText('= ' + dept.organelle, dx + 40, dy + dh * 0.65);

    // Arrow connecting department to next
    if (dept.id !== 'security' && dept.id !== 'recycling') {
      ctx.strokeStyle = '#d1d5db';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 3]);
      ctx.beginPath();
      ctx.moveTo(dx + dw / 2, dy + dh);
      ctx.lineTo(dx + dw / 2, dy + dh + 8);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  });

  // Central flow arrows
  ctx.strokeStyle = '#c41e3a';
  ctx.lineWidth = 2;
  ctx.setLineDash([]);
  const arrowY = H * 0.88;
  ctx.beginPath();
  ctx.moveTo(W * 0.15, arrowY);
  ctx.lineTo(W * 0.85, arrowY);
  ctx.stroke();
  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(W * 0.85, arrowY);
  ctx.lineTo(W * 0.83, arrowY - 5);
  ctx.moveTo(W * 0.85, arrowY);
  ctx.lineTo(W * 0.83, arrowY + 5);
  ctx.stroke();

  ctx.fillStyle = '#c41e3a'; ctx.font = 'bold 11px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('DNA instructions \u2192 Protein assembly \u2192 Processing \u2192 Packaging \u2192 Export', W / 2, arrowY + 16);
}

function setupFactory() {
  const c = $('factory-canvas');
  c.addEventListener('mousemove', e => {
    const rect = c.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const W = c.offsetWidth, H = c.offsetHeight || 500;
    let hit = null;
    factoryDepts.forEach(dept => {
      const dx = W * dept.x - (W * dept.w / 2);
      const dy = H * dept.y;
      const dw = W * dept.w;
      const dh = H * dept.h;
      if (mx >= dx && mx <= dx + dw && my >= dy && my <= dy + dh) hit = dept.id;
    });
    if (hit !== hoveredDept) {
      hoveredDept = hit;
      c.style.cursor = hit ? 'pointer' : 'default';
      drawFactory();
    }
  });

  c.addEventListener('click', e => {
    const rect = c.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const W = c.offsetWidth, H = c.offsetHeight || 500;
    factoryDepts.forEach(dept => {
      const dx = W * dept.x - (W * dept.w / 2);
      const dy = H * dept.y;
      const dw = W * dept.w;
      const dh = H * dept.h;
      if (mx >= dx && mx <= dx + dw && my >= dy && my <= dy + dh) {
        $('factory-info').innerHTML = `
          <div class="ip-title">${dept.name} = ${dept.organelle}</div>
          <div class="ip-function">${dept.desc}</div>`;
      }
    });
  });

  c.addEventListener('mouseleave', () => {
    hoveredDept = null;
    drawFactory();
  });
}


// ══════════════════════════════════════════════════════════════════════════
// PART 6: HUMAN CELL DIVERSITY
// ══════════════════════════════════════════════════════════════════════════
const cellTypes = [
  { id: 'neuron', name: 'Neuron', shape: 'Elongated with long axon and branching dendrites', reason: 'The long axon transmits electrical signals over great distances (up to 1 meter). Dendrites receive signals from many other neurons, enabling complex neural networks.', organelles: 'Abundant mitochondria (especially at synapses for energy), extensive rough ER (Nissl bodies) for neurotransmitter protein production, prominent cytoskeleton (neurofilaments for structural support).', color: '#7c3aed' },
  { id: 'rbc', name: 'Red Blood Cell', shape: 'Biconcave disc, no nucleus', reason: 'The biconcave shape maximizes surface area for oxygen exchange and allows flexibility to squeeze through narrow capillaries. Losing the nucleus makes room for more hemoglobin.', organelles: 'No nucleus, no mitochondria, no organelles in mature form. The entire cell is essentially a bag of hemoglobin optimized for O2 and CO2 transport.', color: '#dc2626' },
  { id: 'wbc', name: 'White Blood Cell', shape: 'Irregular, amoeboid with lobed nucleus', reason: 'The irregular shape allows WBCs to squeeze between tissue cells and move toward infections. Multiple nuclear lobes aid in passing through tight spaces.', organelles: 'Packed with lysosomes for digesting engulfed pathogens. Many mitochondria for energy during immune response. Active Golgi for producing defensive proteins.', color: '#2563eb' },
  { id: 'muscle', name: 'Muscle Cell', shape: 'Elongated, cylindrical, multinucleated', reason: 'The elongated shape allows coordinated contraction along the entire length. Multiple nuclei support the large cell volume. Striations from organized actin-myosin filaments.', organelles: 'Extremely abundant mitochondria for ATP production. Specialized smooth ER (sarcoplasmic reticulum) for calcium storage. Dense cytoskeleton of actin and myosin.', color: '#16a34a' },
  { id: 'epithelial', name: 'Epithelial Cell', shape: 'Flat and tightly packed in sheets', reason: 'Tight packing creates a continuous barrier that protects underlying tissues. The flat shape allows efficient covering of surfaces. Microvilli increase absorption area.', organelles: 'Strong cytoskeleton with keratin filaments. Tight junctions and desmosomes for cell-cell adhesion. Microvilli with actin cores in absorptive types.', color: '#d97706' },
  { id: 'sperm', name: 'Sperm Cell', shape: 'Small head with long flagellum tail', reason: 'The streamlined head minimizes drag during swimming. The flagellum provides motility to reach the egg. The compact design carries only essential DNA.', organelles: 'Midpiece packed with mitochondria to power the flagellum. Acrosome (specialized lysosome) at the head tip contains enzymes to penetrate the egg. Minimal cytoplasm.', color: '#0891b2' },
];

let selectedCellType = null;

function buildCellGallery() {
  const gallery = $('cell-gallery');
  gallery.innerHTML = '';
  cellTypes.forEach(ct => {
    const item = document.createElement('div');
    item.className = 'cell-gallery-item';
    item.id = 'cg-' + ct.id;
    item.innerHTML = `<canvas width="100" height="80" id="cg-canvas-${ct.id}"></canvas><div class="cg-label">${ct.name}</div>`;
    item.onclick = () => selectCellType(ct.id);
    gallery.appendChild(item);
  });

  // Draw thumbnails
  setTimeout(() => {
    cellTypes.forEach(ct => drawCellThumbnail(ct));
  }, 50);
}

function drawCellThumbnail(ct) {
  const c = document.getElementById('cg-canvas-' + ct.id);
  if (!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  const cx = W / 2, cy = H / 2;

  switch (ct.id) {
    case 'neuron':
      // Cell body
      ctx.fillStyle = ct.color + '30';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(cx, cy, 12, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      // Axon
      ctx.beginPath(); ctx.moveTo(cx + 12, cy); ctx.lineTo(W - 8, cy); ctx.stroke();
      // Dendrites
      ctx.lineWidth = 1;
      for (let i = 0; i < 4; i++) {
        const a = Math.PI + (i - 1.5) * 0.5;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(a) * 12, cy + Math.sin(a) * 12);
        ctx.lineTo(cx + Math.cos(a) * 28, cy + Math.sin(a) * 28);
        ctx.stroke();
      }
      break;
    case 'rbc':
      ctx.fillStyle = ct.color + '30';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.ellipse(cx, cy, 18, 12, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = ct.color + '15';
      ctx.beginPath(); ctx.ellipse(cx, cy, 8, 5, 0, 0, Math.PI * 2); ctx.fill();
      break;
    case 'wbc':
      ctx.fillStyle = ct.color + '30';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 1.5;
      // Irregular shape
      ctx.beginPath();
      for (let a = 0; a < Math.PI * 2; a += 0.4) {
        const r = 14 + Math.sin(a * 3) * 4;
        const px = cx + Math.cos(a) * r, py = cy + Math.sin(a) * r;
        a === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();
      // Lobed nucleus
      ctx.fillStyle = ct.color + '60';
      ctx.beginPath(); ctx.arc(cx - 4, cy - 2, 5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 4, cy + 2, 5, 0, Math.PI * 2); ctx.fill();
      break;
    case 'muscle':
      ctx.fillStyle = ct.color + '30';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.roundRect(8, cy - 8, W - 16, 16, 8);
      ctx.fill(); ctx.stroke();
      // Striations
      ctx.strokeStyle = ct.color + '40';
      ctx.lineWidth = 1;
      for (let x = 14; x < W - 14; x += 6) {
        ctx.beginPath(); ctx.moveTo(x, cy - 6); ctx.lineTo(x, cy + 6); ctx.stroke();
      }
      // Nuclei
      ctx.fillStyle = ct.color + '60';
      ctx.beginPath(); ctx.arc(25, cy - 4, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(55, cy - 4, 3, 0, Math.PI * 2); ctx.fill();
      break;
    case 'epithelial':
      ctx.fillStyle = ct.color + '30';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 2; j++) {
          ctx.fillRect(10 + i * 26, 15 + j * 25, 24, 23);
          ctx.strokeRect(10 + i * 26, 15 + j * 25, 24, 23);
        }
      }
      break;
    case 'sperm':
      ctx.fillStyle = ct.color + '40';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 1.5;
      // Head
      ctx.beginPath(); ctx.ellipse(25, cy, 6, 8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      // Tail
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(31, cy);
      for (let x = 31; x < W - 8; x += 2) {
        ctx.lineTo(x, cy + Math.sin((x - 31) * 0.15) * 6);
      }
      ctx.stroke();
      break;
  }
}

function selectCellType(id) {
  selectedCellType = id;
  // Update gallery selection
  document.querySelectorAll('.cell-gallery-item').forEach(el => el.classList.remove('selected'));
  const item = document.getElementById('cg-' + id);
  if (item) item.classList.add('selected');

  const ct = cellTypes.find(c => c.id === id);
  $('diversity-info').innerHTML = `
    <div class="ip-title">${ct.name}</div>
    <div class="ip-function"><strong>Shape:</strong> ${ct.shape}<br><strong>Why this shape?</strong> ${ct.reason}</div>
    <div class="ip-context"><strong>Key organelles:</strong> ${ct.organelles}</div>`;

  drawDiversityCell(id);
}

function drawDiversityCell(id) {
  const ctx = getCtx('diversity-canvas');
  const W = ctx.W, H = ctx.H;
  const cx = W / 2, cy = H / 2;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const ct = cellTypes.find(c => c.id === id);
  if (!ct) {
    ctx.fillStyle = '#9ca3af'; ctx.font = '14px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Select a cell type from the gallery above', cx, cy);
    return;
  }

  ctx.font = 'bold 18px system-ui'; ctx.textAlign = 'center'; ctx.fillStyle = ct.color;
  ctx.fillText(ct.name, cx, 30);

  switch (id) {
    case 'neuron': drawNeuron(ctx, W, H, ct); break;
    case 'rbc': drawRBC(ctx, W, H, ct); break;
    case 'wbc': drawWBC(ctx, W, H, ct); break;
    case 'muscle': drawMuscle(ctx, W, H, ct); break;
    case 'epithelial': drawEpithelial(ctx, W, H, ct); break;
    case 'sperm': drawSperm(ctx, W, H, ct); break;
  }
}

function drawNeuron(ctx, W, H, ct) {
  const cx = W * 0.3, cy = H * 0.5;
  const bodyR = 40;

  // Dendrites
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 3;
  for (let i = 0; i < 6; i++) {
    const a = Math.PI * 0.6 + (i / 5) * Math.PI * 0.8;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(a) * bodyR, cy + Math.sin(a) * bodyR);
    const len = 50 + Math.random() * 40;
    const mx = cx + Math.cos(a) * (bodyR + len * 0.5);
    const my = cy + Math.sin(a) * (bodyR + len * 0.5) + (Math.random() - 0.5) * 20;
    const ex = cx + Math.cos(a) * (bodyR + len);
    const ey = cy + Math.sin(a) * (bodyR + len);
    ctx.bezierCurveTo(mx, my, mx, my, ex, ey);
    ctx.stroke();
    // Branch tips
    ctx.lineWidth = 1.5;
    for (let b = 0; b < 2; b++) {
      const ba = a + (b - 0.5) * 0.4;
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex + Math.cos(ba) * 15, ey + Math.sin(ba) * 15);
      ctx.stroke();
    }
    ctx.lineWidth = 3;
  }

  // Axon
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(cx + bodyR, cy);
  ctx.lineTo(W * 0.85, cy);
  ctx.stroke();

  // Myelin sheath segments
  ctx.fillStyle = ct.color + '20';
  ctx.strokeStyle = ct.color + '60';
  ctx.lineWidth = 1.5;
  for (let x = cx + bodyR + 15; x < W * 0.8; x += 40) {
    ctx.beginPath();
    ctx.ellipse(x + 12, cy, 12, 14, 0, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();
  }

  // Axon terminal
  ctx.fillStyle = ct.color + '30';
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2;
  for (let i = 0; i < 3; i++) {
    const tx = W * 0.85 + 10;
    const ty = cy - 15 + i * 15;
    ctx.beginPath(); ctx.arc(tx, ty, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  }

  // Cell body
  const grad = ctx.createRadialGradient(cx - 5, cy - 5, 0, cx, cy, bodyR);
  grad.addColorStop(0, ct.color + '40');
  grad.addColorStop(1, ct.color + '15');
  ctx.fillStyle = grad;
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(cx, cy, bodyR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Nucleus
  ctx.fillStyle = ct.color + '50';
  ctx.beginPath(); ctx.arc(cx, cy, bodyR * 0.4, 0, Math.PI * 2); ctx.fill();

  // Labels
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Cell Body', cx, cy + bodyR + 20);
  ctx.fillText('Dendrites', cx - bodyR - 40, cy - bodyR - 10);
  ctx.fillText('Axon', (cx + bodyR + W * 0.85) / 2, cy - 25);
  ctx.fillText('Axon Terminals', W * 0.85 + 10, cy + 40);
  ctx.fillText('Myelin Sheath', cx + bodyR + 60, cy + 30);
}

function drawRBC(ctx, W, H, ct) {
  const cx = W / 2, cy = H / 2;

  // Main RBC - biconcave disc (side view)
  ctx.save();
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 80);
  grad.addColorStop(0, 'rgba(255,200,200,0.5)');
  grad.addColorStop(0.4, ct.color + '30');
  grad.addColorStop(0.7, ct.color + '50');
  grad.addColorStop(1, ct.color + '30');
  ctx.fillStyle = grad;
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(cx, cy, 80, 55, 0, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();

  // Inner concavity
  ctx.fillStyle = 'rgba(255,220,220,0.4)';
  ctx.beginPath();
  ctx.ellipse(cx, cy, 30, 20, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Cross-section view
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Top View', cx, cy - 80);

  // Side view (small)
  const sx = cx + 140, sy = cy;
  ctx.fillStyle = ct.color + '30';
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(sx - 40, sy);
  ctx.bezierCurveTo(sx - 40, sy - 20, sx - 15, sy - 12, sx, sy - 15);
  ctx.bezierCurveTo(sx + 15, sy - 12, sx + 40, sy - 20, sx + 40, sy);
  ctx.bezierCurveTo(sx + 40, sy + 20, sx + 15, sy + 12, sx, sy + 15);
  ctx.bezierCurveTo(sx - 15, sy + 12, sx - 40, sy + 20, sx - 40, sy);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui';
  ctx.fillText('Side View (biconcave)', sx, sy + 35);

  // Labels
  ctx.font = '12px system-ui';
  ctx.fillText('No nucleus', cx, cy + 75);
  ctx.fillText('~7-8 \u03BCm diameter', cx, cy + 92);
  ctx.fillText('Filled with hemoglobin', cx, cy + 109);
}

function drawWBC(ctx, W, H, ct) {
  const cx = W / 2, cy = H / 2;
  const r = 60;

  // Irregular cell body
  ctx.fillStyle = ct.color + '15';
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let a = 0; a < Math.PI * 2; a += 0.2) {
    const rr = r + Math.sin(a * 3.5) * 15 + Math.cos(a * 2.7) * 10;
    const px = cx + Math.cos(a) * rr, py = cy + Math.sin(a) * rr;
    a === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  // Pseudopod
  ctx.fillStyle = ct.color + '10';
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cx + r * 0.7, cy - r * 0.3);
  ctx.bezierCurveTo(cx + r * 1.5, cy - r * 0.8, cx + r * 1.8, cy - r * 0.2, cx + r * 1.3, cy + r * 0.1);
  ctx.fill(); ctx.stroke();

  // Multilobed nucleus
  ctx.fillStyle = ct.color + '40';
  ctx.strokeStyle = ct.color + '80';
  ctx.lineWidth = 1.5;
  const lobes = [
    { x: cx - 15, y: cy - 10, r: 16 },
    { x: cx + 10, y: cy + 5, r: 14 },
    { x: cx - 5, y: cy + 20, r: 12 }
  ];
  lobes.forEach(l => {
    ctx.beginPath(); ctx.arc(l.x, l.y, l.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  });

  // Lysosomes (granules)
  ctx.fillStyle = '#ea580c40';
  ctx.strokeStyle = '#ea580c80';
  ctx.lineWidth = 1;
  for (let i = 0; i < 10; i++) {
    const a = Math.random() * Math.PI * 2;
    const d = Math.random() * r * 0.6;
    ctx.beginPath();
    ctx.arc(cx + Math.cos(a) * d, cy + Math.sin(a) * d, 4, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();
  }

  // Labels
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Lobed Nucleus', cx, cy - r - 15);
  ctx.fillText('Pseudopod', cx + r * 1.5, cy - r * 0.5);
  ctx.fillText('Lysosomes (granules)', cx - r - 30, cy + r + 15);
  ctx.font = '12px system-ui';
  ctx.fillText('~12-15 \u03BCm diameter', cx, cy + r + 35);
}

function drawMuscle(ctx, W, H, ct) {
  const cy = H / 2;
  const mh = 50, mx = 40, mw = W - 80;

  // Cell outline
  ctx.fillStyle = ct.color + '15';
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.roundRect(mx, cy - mh, mw, mh * 2, 10);
  ctx.fill(); ctx.stroke();

  // Striations (sarcomere pattern)
  ctx.strokeStyle = ct.color + '40';
  ctx.lineWidth = 1;
  for (let x = mx + 15; x < mx + mw - 15; x += 12) {
    ctx.beginPath();
    ctx.moveTo(x, cy - mh + 5);
    ctx.lineTo(x, cy + mh - 5);
    ctx.stroke();
  }

  // A-bands (darker)
  ctx.fillStyle = ct.color + '15';
  for (let x = mx + 15; x < mx + mw - 15; x += 24) {
    ctx.fillRect(x, cy - mh + 5, 12, mh * 2 - 10);
  }

  // Multiple nuclei
  ctx.fillStyle = ct.color + '50';
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 1.5;
  for (let i = 0; i < 4; i++) {
    const nx = mx + 60 + i * (mw - 120) / 3;
    ctx.beginPath();
    ctx.ellipse(nx, cy - mh + 12, 12, 6, 0, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();
  }

  // Mitochondria between myofibrils
  ctx.fillStyle = 'rgba(22,163,74,0.3)';
  ctx.strokeStyle = 'rgba(22,163,74,0.6)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 6; i++) {
    const mx2 = mx + 50 + i * (mw - 100) / 5;
    ctx.beginPath();
    ctx.ellipse(mx2, cy + mh - 15, 8, 4, 0.3, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();
  }

  // Labels
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Sarcomere (contractile unit)', W / 2, cy - mh - 30);
  ctx.fillText('Multiple Nuclei', W / 2, cy - mh - 10);
  ctx.fillText('Mitochondria', W / 2, cy + mh + 25);
  ctx.font = '12px system-ui';
  ctx.fillText('Skeletal muscle fiber: up to 30 cm long, 10-100 \u03BCm diameter', W / 2, cy + mh + 45);

  // Sarcomere detail arrow
  ctx.strokeStyle = '#374151'; ctx.lineWidth = 1;
  const sStart = mx + 15, sEnd = mx + 39;
  ctx.beginPath();
  ctx.moveTo(sStart, cy - mh - 22);
  ctx.lineTo(sStart, cy - mh + 2);
  ctx.moveTo(sEnd, cy - mh - 22);
  ctx.lineTo(sEnd, cy - mh + 2);
  ctx.moveTo(sStart, cy - mh - 22);
  ctx.lineTo(sEnd, cy - mh - 22);
  ctx.stroke();
}

function drawEpithelial(ctx, W, H, ct) {
  const startX = W * 0.15, startY = H * 0.2;
  const cellW = 55, cellH = 50;
  const cols = 6, rows = 3;

  // Draw tightly packed cells
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const x = startX + c * cellW;
      const y = startY + r * cellH;

      ctx.fillStyle = ct.color + '15';
      ctx.strokeStyle = ct.color;
      ctx.lineWidth = 2;
      ctx.fillRect(x, y, cellW, cellH);
      ctx.strokeRect(x, y, cellW, cellH);

      // Nucleus
      ctx.fillStyle = ct.color + '40';
      ctx.beginPath();
      ctx.ellipse(x + cellW / 2, y + cellH / 2, 10, 8, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Tight junctions (between cells)
  ctx.strokeStyle = '#c41e3a';
  ctx.lineWidth = 2;
  ctx.setLineDash([3, 3]);
  for (let c = 1; c < cols; c++) {
    const x = startX + c * cellW;
    ctx.beginPath();
    ctx.moveTo(x, startY);
    ctx.lineTo(x, startY + rows * cellH);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // Microvilli on top
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 1;
  for (let x = startX + 5; x < startX + cols * cellW; x += 6) {
    ctx.beginPath();
    ctx.moveTo(x, startY);
    ctx.lineTo(x, startY - 12);
    ctx.stroke();
  }

  // Basement membrane
  ctx.strokeStyle = '#6b7280';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(startX, startY + rows * cellH + 5);
  ctx.lineTo(startX + cols * cellW, startY + rows * cellH + 5);
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Microvilli', startX + cols * cellW / 2, startY - 22);
  ctx.fillText('Tight Junctions', startX + cols * cellW + 50, startY + cellH);
  ctx.fillText('Basement Membrane', startX + cols * cellW / 2, startY + rows * cellH + 25);
  ctx.font = '12px system-ui';
  ctx.fillText('Epithelial cells line body surfaces and cavities', W / 2, H - 30);
}

function drawSperm(ctx, W, H, ct) {
  const headX = W * 0.2, headY = H * 0.5;

  // Head
  const grad = ctx.createRadialGradient(headX - 3, headY - 3, 0, headX, headY, 25);
  grad.addColorStop(0, ct.color + '50');
  grad.addColorStop(1, ct.color + '20');
  ctx.fillStyle = grad;
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.ellipse(headX, headY, 18, 25, 0, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();

  // Acrosome cap
  ctx.fillStyle = ct.color + '40';
  ctx.beginPath();
  ctx.ellipse(headX, headY - 12, 14, 13, 0, Math.PI, Math.PI * 2);
  ctx.fill();

  // Nucleus (fills most of head)
  ctx.fillStyle = ct.color + '30';
  ctx.beginPath();
  ctx.ellipse(headX, headY + 3, 12, 15, 0, 0, Math.PI * 2);
  ctx.fill();

  // Midpiece
  const midStart = headX, midEnd = headX + 60;
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(midStart, headY + 25);
  ctx.lineTo(midEnd, headY + 25);
  ctx.stroke();

  // Mitochondrial spiral
  ctx.strokeStyle = 'rgba(22,163,74,0.6)';
  ctx.lineWidth = 1.5;
  for (let x = midStart + 3; x < midEnd; x += 5) {
    ctx.beginPath();
    ctx.moveTo(x, headY + 20);
    ctx.lineTo(x + 2, headY + 30);
    ctx.stroke();
  }

  // Flagellum (tail)
  ctx.strokeStyle = ct.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(midEnd, headY + 25);
  for (let x = midEnd; x < W * 0.85; x += 3) {
    const amplitude = 15 * (1 - (x - midEnd) / (W * 0.65)) + 3;
    ctx.lineTo(x, headY + 25 + Math.sin((x - midEnd) * 0.06) * amplitude);
  }
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Acrosome', headX, headY - 40);
  ctx.fillText('Head (nucleus)', headX, headY + 55);
  ctx.fillText('Midpiece', (midStart + midEnd) / 2, headY + 50);
  ctx.fillStyle = '#16a34a'; ctx.font = '11px system-ui';
  ctx.fillText('(mitochondria)', (midStart + midEnd) / 2, headY + 63);
  ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui';
  ctx.fillText('Flagellum (tail)', W * 0.6, headY - 10);
  ctx.font = '12px system-ui';
  ctx.fillText('Total length: ~50-60 \u03BCm', W / 2, H - 30);
}


// ══════════════════════════════════════════════════════════════════════════
// SIDEBAR SCROLL HIGHLIGHT
// ══════════════════════════════════════════════════════════════════════════
function updateSidebar() {
  const sections = document.querySelectorAll('.section, .hero');
  const links = document.querySelectorAll('.sidebar-nav a');
  let current = '';
  sections.forEach(s => {
    if (window.scrollY >= s.offsetTop - 100) current = s.id;
  });
  links.forEach(a => {
    a.classList.toggle('active', a.getAttribute('href') === '#' + current);
  });
}
window.addEventListener('scroll', updateSidebar);


// ══════════════════════════════════════════════════════════════════════════
// INIT
// ══════════════════════════════════════════════════════════════════════════
window.addEventListener('DOMContentLoaded', () => {
  drawCellExplorer();
  setupCellExplorer();
  drawMicroscope();
  updateMicroInfo();
  buildCompGrid();
  drawSizeScale();
  drawVenn();
  matchReset();
  setupMatchGame();
  drawFactory();
  setupFactory();
  buildCellGallery();
  // Draw initial diversity canvas
  const dctx = getCtx('diversity-canvas');
  dctx.fillStyle = '#9ca3af'; dctx.font = '14px system-ui'; dctx.textAlign = 'center';
  dctx.fillText('Select a cell type from the gallery above', dctx.W / 2, dctx.H / 2);
});

window.addEventListener('resize', () => {
  drawCellExplorer();
  drawMicroscope();
  drawSizeScale();
  drawVenn();
  drawFactory();
  if (matchState.functions.length) drawMatchGame();
  if (selectedCellType) drawDiversityCell(selectedCellType);
  // Redraw thumbnails
  cellTypes.forEach(ct => drawCellThumbnail(ct));
});
</script>
</body>
</html>
